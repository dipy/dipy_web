{"parents": [], "prev": null, "next": null, "title": "Symmetric Diffeomorphic Registration in 3D", "meta": {}, "body": "<div class=\"section\" id=\"symmetric-diffeomorphic-registration-in-3d\">\n<span id=\"example-syn-registration-3d\"></span><h1>Symmetric Diffeomorphic Registration in 3D<a class=\"headerlink\" href=\"#symmetric-diffeomorphic-registration-in-3d\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>This example explains how to register 3D volumes using the Symmetric Normalization\n(SyN) algorithm proposed by Avants et al. <a class=\"reference internal\" href=\"#avants09\" id=\"id1\">[Avants09]</a> (also implemented in\nthe ANTS software <a class=\"reference internal\" href=\"#avants11\" id=\"id2\">[Avants11]</a>)</p>\n<p>We will register two 3D volumes from the same modality using SyN with the Cross\nCorrelation (CC) metric.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">nibabel</span> <span class=\"k\">as</span> <span class=\"nn\">nib</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.align.imwarp</span> <span class=\"k\">import</span> <span class=\"n\">SymmetricDiffeomorphicRegistration</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.align.imwarp</span> <span class=\"k\">import</span> <span class=\"n\">DiffeomorphicMap</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.align.metrics</span> <span class=\"k\">import</span> <span class=\"n\">CCMetric</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os.path</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"k\">import</span> <span class=\"n\">regtools</span>\n</pre></div>\n</div>\n<p>Let\u2019s fetch two b0 volumes, the first one will be the b0 from the Stanford\nHARDI dataset</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">fetch_stanford_hardi</span><span class=\"p\">,</span> <span class=\"n\">read_stanford_hardi</span>\n<span class=\"n\">fetch_stanford_hardi</span><span class=\"p\">()</span>\n<span class=\"n\">nib_stanford</span><span class=\"p\">,</span> <span class=\"n\">gtab_stanford</span> <span class=\"o\">=</span> <span class=\"n\">read_stanford_hardi</span><span class=\"p\">()</span>\n<span class=\"n\">stanford_b0</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">squeeze</span><span class=\"p\">(</span><span class=\"n\">nib_stanford</span><span class=\"o\">.</span><span class=\"n\">get_data</span><span class=\"p\">())[</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n</pre></div>\n</div>\n<p>The second one will be the same b0 we used for the 2D registration tutorial</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data.fetcher</span> <span class=\"k\">import</span> <span class=\"n\">fetch_syn_data</span><span class=\"p\">,</span> <span class=\"n\">read_syn_data</span>\n<span class=\"n\">fetch_syn_data</span><span class=\"p\">()</span>\n<span class=\"n\">nib_syn_t1</span><span class=\"p\">,</span> <span class=\"n\">nib_syn_b0</span> <span class=\"o\">=</span> <span class=\"n\">read_syn_data</span><span class=\"p\">()</span>\n<span class=\"n\">syn_b0</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">nib_syn_b0</span><span class=\"o\">.</span><span class=\"n\">get_data</span><span class=\"p\">())</span>\n</pre></div>\n</div>\n<p>We first remove the skull from the b0\u2019s</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.mask</span> <span class=\"k\">import</span> <span class=\"n\">median_otsu</span>\n<span class=\"n\">stanford_b0_masked</span><span class=\"p\">,</span> <span class=\"n\">stanford_b0_mask</span> <span class=\"o\">=</span> <span class=\"n\">median_otsu</span><span class=\"p\">(</span><span class=\"n\">stanford_b0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"n\">syn_b0_masked</span><span class=\"p\">,</span> <span class=\"n\">syn_b0_mask</span> <span class=\"o\">=</span> <span class=\"n\">median_otsu</span><span class=\"p\">(</span><span class=\"n\">syn_b0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n\n<span class=\"n\">static</span> <span class=\"o\">=</span> <span class=\"n\">stanford_b0_masked</span>\n<span class=\"n\">static_affine</span> <span class=\"o\">=</span> <span class=\"n\">nib_stanford</span><span class=\"o\">.</span><span class=\"n\">affine</span>\n<span class=\"n\">moving</span> <span class=\"o\">=</span> <span class=\"n\">syn_b0_masked</span>\n<span class=\"n\">moving_affine</span> <span class=\"o\">=</span> <span class=\"n\">nib_syn_b0</span><span class=\"o\">.</span><span class=\"n\">affine</span>\n</pre></div>\n</div>\n<p>Suppose we have already done a linear registration to roughly align the two\nimages</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">pre_align</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">1.02783543e+00</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">4.83019053e-02</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">6.07735639e-02</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">2.57654118e+00</span><span class=\"p\">],</span>\n                      <span class=\"p\">[</span><span class=\"mf\">4.34051706e-03</span><span class=\"p\">,</span> <span class=\"mf\">9.41918267e-01</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">2.66525861e-01</span><span class=\"p\">,</span> <span class=\"mf\">3.23579799e+01</span><span class=\"p\">],</span>\n                      <span class=\"p\">[</span><span class=\"mf\">5.34288908e-02</span><span class=\"p\">,</span> <span class=\"mf\">2.90262026e-01</span><span class=\"p\">,</span> <span class=\"mf\">9.80820307e-01</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.46216651e+01</span><span class=\"p\">],</span>\n                      <span class=\"p\">[</span><span class=\"mf\">0.00000000e+00</span><span class=\"p\">,</span> <span class=\"mf\">0.00000000e+00</span><span class=\"p\">,</span> <span class=\"mf\">0.00000000e+00</span><span class=\"p\">,</span> <span class=\"mf\">1.00000000e+00</span><span class=\"p\">]])</span>\n</pre></div>\n</div>\n<p>As we did in the 2D example, we would like to visualize (some slices of) the two\nvolumes by overlapping them over two channels of a color image. To do that we\nneed them to be sampled on the same grid, so let\u2019s first re-sample the moving\nimage on the static grid. We create an AffineMap to transform the moving image\ntowards the static image</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.align.imaffine</span> <span class=\"k\">import</span> <span class=\"n\">AffineMap</span>\n<span class=\"n\">affine_map</span> <span class=\"o\">=</span> <span class=\"n\">AffineMap</span><span class=\"p\">(</span><span class=\"n\">pre_align</span><span class=\"p\">,</span>\n                       <span class=\"n\">static</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">static_affine</span><span class=\"p\">,</span>\n                       <span class=\"n\">moving</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">moving_affine</span><span class=\"p\">)</span>\n\n<span class=\"n\">resampled</span> <span class=\"o\">=</span> <span class=\"n\">affine_map</span><span class=\"o\">.</span><span class=\"n\">transform</span><span class=\"p\">(</span><span class=\"n\">moving</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>plot the overlapped middle slices of the volumes</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">regtools</span><span class=\"o\">.</span><span class=\"n\">overlay_slices</span><span class=\"p\">(</span><span class=\"n\">static</span><span class=\"p\">,</span> <span class=\"n\">resampled</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Static&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Moving&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;input_3d.png&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"figure align-center\" id=\"id4\">\n<img alt=\"../../_images/input_3d.png\" src=\"../../_images/input_3d.png\" />\n<p class=\"caption\"><span class=\"caption-text\">Static image in red on top of the pre-aligned moving image (in green).</span></p>\n</div>\n<p>We want to find an invertible map that transforms the moving image into the\nstatic image. We will use the Cross Correlation metric</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">CCMetric</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Now we define an instance of the registration class. The SyN algorithm uses\na multi-resolution approach by building a Gaussian Pyramid. We instruct the\nregistration object to perform at most <span class=\"math notranslate nohighlight\">\\([n_0, n_1, ..., n_k]\\)</span> iterations at\neach level of the pyramid. The 0-th level corresponds to the finest resolution.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">level_iters</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]</span>\n<span class=\"n\">sdr</span> <span class=\"o\">=</span> <span class=\"n\">SymmetricDiffeomorphicRegistration</span><span class=\"p\">(</span><span class=\"n\">metric</span><span class=\"p\">,</span> <span class=\"n\">level_iters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Execute the optimization, which returns a DiffeomorphicMap object,\nthat can be used to register images back and forth between the static and moving\ndomains. We provide the pre-aligning matrix that brings the moving image closer\nto the static image</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">mapping</span> <span class=\"o\">=</span> <span class=\"n\">sdr</span><span class=\"o\">.</span><span class=\"n\">optimize</span><span class=\"p\">(</span><span class=\"n\">static</span><span class=\"p\">,</span> <span class=\"n\">moving</span><span class=\"p\">,</span> <span class=\"n\">static_affine</span><span class=\"p\">,</span> <span class=\"n\">moving_affine</span><span class=\"p\">,</span> <span class=\"n\">pre_align</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Now let\u2019s warp the moving image and see if it gets similar to the static image</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">warped_moving</span> <span class=\"o\">=</span> <span class=\"n\">mapping</span><span class=\"o\">.</span><span class=\"n\">transform</span><span class=\"p\">(</span><span class=\"n\">moving</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We plot the overlapped middle slices</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">regtools</span><span class=\"o\">.</span><span class=\"n\">overlay_slices</span><span class=\"p\">(</span><span class=\"n\">static</span><span class=\"p\">,</span> <span class=\"n\">warped_moving</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Static&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Warped moving&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;warped_moving.png&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"figure align-center\" id=\"id5\">\n<img alt=\"../../_images/warped_moving.png\" src=\"../../_images/warped_moving.png\" />\n<p class=\"caption\"><span class=\"caption-text\">Moving image transformed under the (direct) transformation in green on top\nof the static image (in red).</span></p>\n</div>\n<p>And we can also apply the inverse mapping to verify that the warped static image\nis similar to the moving image</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">warped_static</span> <span class=\"o\">=</span> <span class=\"n\">mapping</span><span class=\"o\">.</span><span class=\"n\">transform_inverse</span><span class=\"p\">(</span><span class=\"n\">static</span><span class=\"p\">)</span>\n<span class=\"n\">regtools</span><span class=\"o\">.</span><span class=\"n\">overlay_slices</span><span class=\"p\">(</span><span class=\"n\">warped_static</span><span class=\"p\">,</span> <span class=\"n\">moving</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Warped static&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Moving&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;warped_static.png&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"figure align-center\" id=\"id6\">\n<img alt=\"../../_images/warped_static.png\" src=\"../../_images/warped_static.png\" />\n<p class=\"caption\"><span class=\"caption-text\">Static image transformed under the (inverse) transformation in red on top of\nthe moving image (in green). Note that the moving image has lower resolution.</span></p>\n</div>\n<div class=\"section\" id=\"references\">\n<h2>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"docutils citation\" frame=\"void\" id=\"avants09\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#id1\">[Avants09]</a></td><td>Avants, B. B., Epstein, C. L., Grossman, M., &amp; Gee, J. C. (2009).\nSymmetric Diffeomorphic Image Registration with Cross- Correlation:\nEvaluating Automated Labeling of Elderly and Neurodegenerative Brain, 12(1),\n26-41.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils citation\" frame=\"void\" id=\"avants11\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#id2\">[Avants11]</a></td><td>Avants, B. B., Tustison, N., &amp; Song, G. (2011). Advanced\nNormalization Tools ( ANTS ), 1-35.</td></tr>\n</tbody>\n</table>\n<div class=\"admonition-example-source-code admonition\">\n<p class=\"first admonition-title\">Example source code</p>\n<p class=\"last\">You can download <a class=\"reference download internal\" href=\"../../_downloads/syn_registration_3d.py\" download=\"\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">the</span> <span class=\"pre\">full</span> <span class=\"pre\">source</span> <span class=\"pre\">code</span> <span class=\"pre\">of</span> <span class=\"pre\">this</span> <span class=\"pre\">example</span></code></a>. This same script is also included in the dipy source distribution under the <code class=\"file docutils literal notranslate\"><span class=\"pre\">doc/examples/</span></code> directory.</p>\n</div>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"]], "sourcename": "examples_built/syn_registration_3d.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Symmetric Diffeomorphic Registration in 3D</a><ul>\n<li><a class=\"reference internal\" href=\"#references\">References</a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "examples_built/syn_registration_3d", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.11"}
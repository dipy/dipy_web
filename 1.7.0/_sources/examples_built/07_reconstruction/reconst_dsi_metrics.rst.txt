
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples_built/07_reconstruction/reconst_dsi_metrics.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_built_07_reconstruction_reconst_dsi_metrics.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_built_07_reconstruction_reconst_dsi_metrics.py:


===============================
Calculate DSI-based scalar maps
===============================

We show how to calculate two DSI-based scalar maps: return to origin
probability (RTOP) [Descoteaux2011]_ and mean square displacement (MSD)
[Wu2007]_, [Wu2008]_ on your dataset.

First import the necessary modules:

.. GENERATED FROM PYTHON SOURCE LINES 12-21

.. code-block:: default


    import numpy as np
    import matplotlib.pyplot as plt
    from dipy.core.gradients import gradient_table
    from dipy.data import get_fnames
    from dipy.io.gradients import read_bvals_bvecs
    from dipy.io.image import load_nifti
    from dipy.reconst.dsi import DiffusionSpectrumModel








.. GENERATED FROM PYTHON SOURCE LINES 22-23

Download and get the data filenames for this tutorial.

.. GENERATED FROM PYTHON SOURCE LINES 23-27

.. code-block:: default



    fraw, fbval, fbvec = get_fnames('taiwan_ntu_dsi')








.. GENERATED FROM PYTHON SOURCE LINES 28-33

img contains a nibabel Nifti1Image object (data) and gtab contains a
GradientTable object (gradient information e.g. b-values). For example to read
the b-values it is possible to write print(gtab.bvals).

Load the raw diffusion data and the affine.

.. GENERATED FROM PYTHON SOURCE LINES 33-43

.. code-block:: default



    data, affine = load_nifti(fraw)
    bvals, bvecs = read_bvals_bvecs(fbval, fbvec)
    bvecs[1:] = (bvecs[1:] /
                     np.sqrt(np.sum(bvecs[1:] * bvecs[1:], axis=1))[:, None])
    gtab = gradient_table(bvals, bvecs)

    print('data.shape (%d, %d, %d, %d)' % data.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    data.shape (96, 96, 60, 203)




.. GENERATED FROM PYTHON SOURCE LINES 44-45

Instantiate the Model and apply it to the data.

.. GENERATED FROM PYTHON SOURCE LINES 45-49

.. code-block:: default



    dsmodel = DiffusionSpectrumModel(gtab, qgrid_size=35, filter_width=18.5)








.. GENERATED FROM PYTHON SOURCE LINES 50-51

Let's just use one slice only from the data.

.. GENERATED FROM PYTHON SOURCE LINES 51-55

.. code-block:: default



    dataslice = data[30:70, 20:80, data.shape[2] // 2]








.. GENERATED FROM PYTHON SOURCE LINES 56-57

Normalize the signal by the b0

.. GENERATED FROM PYTHON SOURCE LINES 57-61

.. code-block:: default



    dataslice = dataslice / (dataslice[..., 0, None]).astype(float)








.. GENERATED FROM PYTHON SOURCE LINES 62-64

Calculate the return to origin probability on the signal
that corresponds to the integral of the signal.

.. GENERATED FROM PYTHON SOURCE LINES 64-69

.. code-block:: default



    print('Calculating... rtop_signal')
    rtop_signal = dsmodel.fit(dataslice).rtop_signal()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... rtop_signal
      0%|          | 0/2400 [00:00<?, ?it/s]    100%|##########| 2400/2400 [00:00<00:00, 632386.58it/s]




.. GENERATED FROM PYTHON SOURCE LINES 70-75

Now we calculate the return to origin probability on the propagator, that
corresponds to its central value. By default the propagator is divided by its
sum in order to obtain a properly normalized pdf, however this normalization
changes the values of RTOP, therefore in order to compare it with the RTOP
previously calculated on the signal we turn the normalized parameter to false.

.. GENERATED FROM PYTHON SOURCE LINES 75-80

.. code-block:: default



    print('Calculating... rtop_pdf')
    rtop_pdf = dsmodel.fit(dataslice).rtop_pdf(normalized=False)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... rtop_pdf
      0%|          | 0/2400 [00:00<?, ?it/s]    100%|##########| 2400/2400 [00:00<00:00, 649021.90it/s]




.. GENERATED FROM PYTHON SOURCE LINES 81-83

In theory, these two measures must be equal,
to show that we calculate the mean square error on this two measures.

.. GENERATED FROM PYTHON SOURCE LINES 83-88

.. code-block:: default



    mse = np.sum((rtop_signal - rtop_pdf) ** 2) / rtop_signal.size
    print("mse = %f" % mse)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    mse = 0.000000




.. GENERATED FROM PYTHON SOURCE LINES 89-93

mse = 0.000000

Leaving the normalized parameter to the default changes the values of the
RTOP but not the contrast between the voxels.

.. GENERATED FROM PYTHON SOURCE LINES 93-98

.. code-block:: default



    print('Calculating... rtop_pdf_norm')
    rtop_pdf_norm = dsmodel.fit(dataslice).rtop_pdf()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... rtop_pdf_norm
      0%|          | 0/2400 [00:00<?, ?it/s]    100%|##########| 2400/2400 [00:00<00:00, 645815.72it/s]




.. GENERATED FROM PYTHON SOURCE LINES 99-100

Let's calculate the mean square displacement on the normalized propagator.

.. GENERATED FROM PYTHON SOURCE LINES 100-105

.. code-block:: default



    print('Calculating... msd_norm')
    msd_norm = dsmodel.fit(dataslice).msd_discrete()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... msd_norm
      0%|          | 0/2400 [00:00<?, ?it/s]    100%|##########| 2400/2400 [00:00<00:00, 636787.04it/s]




.. GENERATED FROM PYTHON SOURCE LINES 106-108

Turning the normalized parameter to false makes it possible to calculate
the mean square displacement on the propagator without normalization.

.. GENERATED FROM PYTHON SOURCE LINES 108-113

.. code-block:: default



    print('Calculating... msd')
    msd = dsmodel.fit(dataslice).msd_discrete(normalized=False)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Calculating... msd
      0%|          | 0/2400 [00:00<?, ?it/s]    100%|##########| 2400/2400 [00:00<00:00, 638604.94it/s]




.. GENERATED FROM PYTHON SOURCE LINES 114-115

Show the RTOP images and save them in rtop.png.

.. GENERATED FROM PYTHON SOURCE LINES 115-132

.. code-block:: default



    fig = plt.figure(figsize=(6, 6))
    ax1 = fig.add_subplot(2, 2, 1, title='rtop_signal')
    ax1.set_axis_off()
    ind = ax1.imshow(rtop_signal.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    ax2 = fig.add_subplot(2, 2, 2, title='rtop_pdf_norm')
    ax2.set_axis_off()
    ind = ax2.imshow(rtop_pdf_norm.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    ax3 = fig.add_subplot(2, 2, 3, title='rtop_pdf')
    ax3.set_axis_off()
    ind = ax3.imshow(rtop_pdf.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    plt.savefig('rtop.png')




.. image-sg:: /examples_built/07_reconstruction/images/sphx_glr_reconst_dsi_metrics_001.png
   :alt: reconst dsi metrics
   :srcset: /examples_built/07_reconstruction/images/sphx_glr_reconst_dsi_metrics_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 133-139

.. figure:: rtop.png
   :align: center

   Return to origin probability.

Show the MSD images and save them in msd.png.

.. GENERATED FROM PYTHON SOURCE LINES 139-152

.. code-block:: default



    fig = plt.figure(figsize=(7, 3))
    ax1 = fig.add_subplot(1, 2, 1, title='msd_norm')
    ax1.set_axis_off()
    ind = ax1.imshow(msd_norm.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    ax2 = fig.add_subplot(1, 2, 2, title='msd')
    ax2.set_axis_off()
    ind = ax2.imshow(msd.T, interpolation='nearest', origin='lower')
    plt.colorbar(ind)
    plt.savefig('msd.png')




.. image-sg:: /examples_built/07_reconstruction/images/sphx_glr_reconst_dsi_metrics_002.png
   :alt: reconst dsi metrics
   :srcset: /examples_built/07_reconstruction/images/sphx_glr_reconst_dsi_metrics_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 153-171

.. figure:: msd.png
   :align: center

   Mean square displacement.

.. [Descoteaux2011] Descoteaux M. et al., "Multiple q-shell diffusion
   propagator imaging", Medical Image Analysis, vol 15, no 4, p. 603-621,
   2011.

.. [Wu2007] Wu Y. et al., "Hybrid diffusion imaging", NeuroImage, vol 36,
   p. 617-629, 2007.

.. [Wu2008] Wu Y. et al., "Computation of Diffusion Function Measures in
   q-Space Using Magnetic Resonance Hybrid Diffusion Imaging", IEEE
   Transactions on Medical Imaging, vol 27, no 6, p. 858-865, 2008.

.. include:: ../links_names.inc



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  11.310 seconds)


.. _sphx_glr_download_examples_built_07_reconstruction_reconst_dsi_metrics.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: reconst_dsi_metrics.py <reconst_dsi_metrics.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: reconst_dsi_metrics.ipynb <reconst_dsi_metrics.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_

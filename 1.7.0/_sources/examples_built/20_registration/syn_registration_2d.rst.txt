
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples_built/20_registration/syn_registration_2d.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_built_20_registration_syn_registration_2d.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_built_20_registration_syn_registration_2d.py:


==========================================
Symmetric Diffeomorphic Registration in 2D
==========================================
This example explains how to register 2D images using the Symmetric
Normalization (SyN) algorithm proposed by Avants et al. [Avants09]_
(also implemented in the ANTs software [Avants11]_)

We will perform the classic Circle-To-C experiment for diffeomorphic
registration

.. GENERATED FROM PYTHON SOURCE LINES 12-29

.. code-block:: default


    import numpy as np
    from dipy.align.imwarp import SymmetricDiffeomorphicRegistration
    from dipy.align.metrics import SSDMetric, CCMetric
    import dipy.align.imwarp as imwarp
    from dipy.data import get_fnames
    from dipy.io.image import load_nifti_data
    from dipy.segment.mask import median_otsu
    from dipy.viz import regtools


    fname_moving = get_fnames('reg_o')
    fname_static = get_fnames('reg_c')

    moving = np.load(fname_moving)
    static = np.load(fname_static)








.. GENERATED FROM PYTHON SOURCE LINES 30-33

To visually check the overlap of the static image with the transformed moving
image, we can plot them on top of each other with different channels to see
where the differences are located

.. GENERATED FROM PYTHON SOURCE LINES 33-38

.. code-block:: default



    regtools.overlay_images(static, moving, 'Static', 'Overlay', 'Moving',
                            'input_images.png')




.. image-sg:: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_001.png
   :alt: syn registration 2d
   :srcset: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 39-43

.. figure:: input_images.png
   :align: center

   Input images.

.. GENERATED FROM PYTHON SOURCE LINES 46-52

We want to find an invertible map that transforms the moving image (circle)
into the static image (the C letter).

The first decision we need to make is what similarity metric is appropriate
for our problem. In this example we are using two binary images, so the Sum
of Squared Differences (SSD) is a good choice.

.. GENERATED FROM PYTHON SOURCE LINES 52-57

.. code-block:: default



    dim = static.ndim
    metric = SSDMetric(dim)








.. GENERATED FROM PYTHON SOURCE LINES 58-62

Now we define an instance of the registration class. The SyN algorithm uses
a multi-resolution approach by building a Gaussian Pyramid. We instruct the
registration instance to perform at most $[n_0, n_1, ..., n_k]$ iterations at
each level of the pyramid. The 0-th level corresponds to the finest resolution.

.. GENERATED FROM PYTHON SOURCE LINES 62-68

.. code-block:: default



    level_iters = [200, 100, 50, 25]

    sdr = SymmetricDiffeomorphicRegistration(metric, level_iters, inv_iter=50)








.. GENERATED FROM PYTHON SOURCE LINES 69-72

Now we execute the optimization, which returns a DiffeomorphicMap object,
that can be used to register images back and forth between the static and
moving domains

.. GENERATED FROM PYTHON SOURCE LINES 72-76

.. code-block:: default



    mapping = sdr.optimize(static, moving)








.. GENERATED FROM PYTHON SOURCE LINES 77-79

It is a good idea to visualize the resulting deformation map to make sure the
result is reasonable (at least, visually)

.. GENERATED FROM PYTHON SOURCE LINES 79-83

.. code-block:: default



    regtools.plot_2d_diffeomorphic_map(mapping, 10, 'diffeomorphic_map.png')




.. image-sg:: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_002.png
   :alt: syn registration 2d
   :srcset: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (array([[  0.     ,   0.     ,   0.     , ...,   0.     ,   0.     ,
              0.     ],
           [  0.     , 127.     , 127.00001, ...,   0.     , 127.     ,
            127.     ],
           [  0.     , 127.00001, 127.     , ...,   0.     , 127.     ,
            127.     ],
           ...,
           [  0.     ,   0.     ,   0.     , ...,   0.     ,   0.     ,
              0.     ],
           [  0.     , 127.     , 127.     , ...,   0.     , 127.     ,
            127.     ],
           [  0.     , 127.     , 127.     , ...,   0.     , 127.     ,
            127.     ]], dtype=float32), array([[  0.     ,   0.     ,   0.     , ...,   0.     ,   0.     ,
              0.     ],
           [  0.     , 126.87221, 126.88522, ...,   0.     , 127.     ,
            127.     ],
           [  0.     , 126.86069, 127.     , ...,   0.     , 127.     ,
            127.     ],
           ...,
           [  0.     ,   0.     ,   0.     , ...,   0.     ,   0.     ,
              0.     ],
           [  0.     , 127.     , 127.     , ...,   0.     , 127.     ,
            127.     ],
           [  0.     , 127.     , 127.     , ...,   0.     , 127.     ,
            127.     ]], dtype=float32))



.. GENERATED FROM PYTHON SOURCE LINES 84-88

.. figure:: diffeomorphic_map.png
   :align: center

   Deformed lattice under the resulting diffeomorphic map.

.. GENERATED FROM PYTHON SOURCE LINES 91-92

Now let's warp the moving image and see if it gets similar to the static image

.. GENERATED FROM PYTHON SOURCE LINES 92-98

.. code-block:: default



    warped_moving = mapping.transform(moving, 'linear')
    regtools.overlay_images(static, warped_moving, 'Static', 'Overlay',
                            'Warped moving', 'direct_warp_result.png')




.. image-sg:: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_003.png
   :alt: syn registration 2d
   :srcset: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 99-105

.. figure:: direct_warp_result.png
   :align: center

   Moving image transformed under the (direct) transformation in green on top
   of the static image (in red).


.. GENERATED FROM PYTHON SOURCE LINES 108-110

And we can also apply the inverse mapping to verify that the warped static
image is similar to the moving image

.. GENERATED FROM PYTHON SOURCE LINES 110-116

.. code-block:: default



    warped_static = mapping.transform_inverse(static, 'linear')
    regtools.overlay_images(warped_static, moving, 'Warped static', 'Overlay',
                            'Moving', 'inverse_warp_result.png')




.. image-sg:: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_004.png
   :alt: syn registration 2d
   :srcset: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 117-123

.. figure:: inverse_warp_result.png
   :align: center

   Static image transformed under the (inverse) transformation in red on top
   of the moving image (in green).


.. GENERATED FROM PYTHON SOURCE LINES 126-131

Now let's register a couple of slices from a b0 image using the Cross
Correlation metric. Also, let's inspect the evolution of the registration.
To do this we will define a function that will be called by the registration
object at each stage of the optimization process. We will draw the current
warped images after finishing each resolution.

.. GENERATED FROM PYTHON SOURCE LINES 131-147

.. code-block:: default




    def callback_CC(sdr, status):
        # Status indicates at which stage of the optimization we currently are
        # For now, we will only react at the end of each resolution of the scale
        # space
        if status == imwarp.RegistrationStages.SCALE_END:
            # get the current images from the metric
            wmoving = sdr.metric.moving_image
            wstatic = sdr.metric.static_image
            # draw the images on top of each other with different colors
            regtools.overlay_images(wmoving, wstatic, 'Warped moving', 'Overlay',
                                    'Warped static')









.. GENERATED FROM PYTHON SOURCE LINES 148-149

Now we are ready to configure and run the registration. First load the data

.. GENERATED FROM PYTHON SOURCE LINES 149-154

.. code-block:: default



    t1_name, b0_name = get_fnames('syn_data')
    data = load_nifti_data(b0_name)








.. GENERATED FROM PYTHON SOURCE LINES 155-156

We first remove the skull from the b0 volume

.. GENERATED FROM PYTHON SOURCE LINES 156-160

.. code-block:: default



    b0_mask, mask = median_otsu(data, median_radius=4, numpass=4)








.. GENERATED FROM PYTHON SOURCE LINES 161-162

And select two slices to try the 2D registration

.. GENERATED FROM PYTHON SOURCE LINES 162-167

.. code-block:: default



    static = b0_mask[:, :, 40]
    moving = b0_mask[:, :, 38]








.. GENERATED FROM PYTHON SOURCE LINES 168-173

After loading the data, we instantiate the Cross-Correlation metric. The metric
receives three parameters: the dimension of the input images, the standard
deviation of the Gaussian Kernel to be used to regularize the gradient and the
radius of the window to be used for evaluating the local normalized cross
correlation.

.. GENERATED FROM PYTHON SOURCE LINES 173-179

.. code-block:: default



    sigma_diff = 3.0
    radius = 4
    metric = CCMetric(2, sigma_diff, radius)








.. GENERATED FROM PYTHON SOURCE LINES 180-181

Let's use a scale space of 3 levels

.. GENERATED FROM PYTHON SOURCE LINES 181-187

.. code-block:: default



    level_iters = [100, 50, 25]
    sdr = SymmetricDiffeomorphicRegistration(metric, level_iters)
    sdr.callback = callback_CC








.. GENERATED FROM PYTHON SOURCE LINES 188-189

And execute the optimization

.. GENERATED FROM PYTHON SOURCE LINES 189-195

.. code-block:: default



    mapping = sdr.optimize(static, moving)

    warped = mapping.transform(moving)








.. GENERATED FROM PYTHON SOURCE LINES 196-198

We can see the effect of the warping by switching between the images before and
after registration

.. GENERATED FROM PYTHON SOURCE LINES 198-203

.. code-block:: default



    regtools.overlay_images(static, moving, 'Static', 'Overlay', 'Moving',
                            't1_slices_input.png')




.. image-sg:: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_005.png
   :alt: syn registration 2d
   :srcset: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 204-208

.. figure:: t1_slices_input.png
   :align: center

   Input images.

.. GENERATED FROM PYTHON SOURCE LINES 208-213

.. code-block:: default



    regtools.overlay_images(static, warped, 'Static', 'Overlay', 'Warped moving',
                            't1_slices_res.png')




.. image-sg:: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_006.png
   :alt: syn registration 2d
   :srcset: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 214-220

.. figure:: t1_slices_res.png
   :align: center

   Moving image transformed under the (direct) transformation in green on top
   of the static image (in red).


.. GENERATED FROM PYTHON SOURCE LINES 223-224

And we can apply the inverse warping too

.. GENERATED FROM PYTHON SOURCE LINES 224-230

.. code-block:: default



    inv_warped = mapping.transform_inverse(static)
    regtools.overlay_images(inv_warped, moving, 'Warped static', 'Overlay',
                            'moving', 't1_slices_res2.png')




.. image-sg:: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_007.png
   :alt: syn registration 2d
   :srcset: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_007.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 231-237

.. figure:: t1_slices_res2.png
   :align: center

   Static image transformed under the (inverse) transformation in red on top
   of the moving image (in green).


.. GENERATED FROM PYTHON SOURCE LINES 240-241

Finally, let's see the deformation

.. GENERATED FROM PYTHON SOURCE LINES 241-245

.. code-block:: default



    regtools.plot_2d_diffeomorphic_map(mapping, 5, 'diffeomorphic_map_b0s.png')




.. image-sg:: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_008.png
   :alt: syn registration 2d
   :srcset: /examples_built/20_registration/images/sphx_glr_syn_registration_2d_008.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (array([[  0.     ,   0.     ,   0.     , ...,   0.     ,   0.     ,
              0.     ],
           [  0.     , 126.99999, 127.00001, ..., 127.     ,   0.     ,
            127.     ],
           [  0.     , 127.     , 127.     , ..., 127.     ,   0.     ,
            127.     ],
           ...,
           [  0.     , 127.     , 127.     , ..., 127.     ,   0.     ,
            127.     ],
           [  0.     ,   0.     ,   0.     , ...,   0.     ,   0.     ,
              0.     ],
           [  0.     , 127.     , 127.     , ..., 127.     ,   0.     ,
            127.     ]], dtype=float32), array([[  0.      ,   0.      ,   0.      , ...,   0.      ,   0.      ,
              0.      ],
           [  0.      , 126.99708 , 126.999725, ..., 127.      ,   0.      ,
            127.      ],
           [  0.      , 126.99444 , 127.      , ..., 127.      ,   0.      ,
            127.      ],
           ...,
           [  0.      , 127.      , 127.      , ..., 127.      ,   0.      ,
            127.      ],
           [  0.      ,   0.      ,   0.      , ...,   0.      ,   0.      ,
              0.      ],
           [  0.      , 127.      , 127.      , ..., 127.      ,   0.      ,
            127.      ]], dtype=float32))



.. GENERATED FROM PYTHON SOURCE LINES 246-264

.. figure:: diffeomorphic_map_b0s.png
   :align: center

   Deformed lattice under the resulting diffeomorphic map.

References
----------

.. [Avants09] Avants, B. B., Epstein, C. L., Grossman, M., & Gee, J. C. (2009).
   Symmetric Diffeomorphic Image Registration with Cross-Correlation:
   Evaluating Automated Labeling of Elderly and Neurodegenerative Brain, 12(1),
   26-41.

.. [Avants11] Avants, B. B., Tustison, N., & Song, G. (2011). Advanced
   Normalization Tools (ANTS), 1-35.

.. include:: ../links_names.inc



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  28.795 seconds)


.. _sphx_glr_download_examples_built_20_registration_syn_registration_2d.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: syn_registration_2d.py <syn_registration_2d.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: syn_registration_2d.ipynb <syn_registration_2d.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_

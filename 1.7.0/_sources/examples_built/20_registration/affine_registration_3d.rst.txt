
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples_built/20_registration/affine_registration_3d.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_built_20_registration_affine_registration_3d.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_built_20_registration_affine_registration_3d.py:


=========================
Affine Registration in 3D
=========================

This example explains how to compute an affine transformation to register two
3D volumes by maximization of their Mutual Information [Mattes03]_. The
optimization strategy is similar to that implemented in ANTS [Avants11]_.

We will do this twice. The first part of this tutorial will walk through the
details of the process with the object-oriented interface implemented in
the ``dipy.align`` module. The second part will use a simplified functional
interface.

.. GENERATED FROM PYTHON SOURCE LINES 15-30

.. code-block:: default


    from os.path import join as pjoin
    import numpy as np
    from dipy.viz import regtools
    from dipy.data import fetch_stanford_hardi
    from dipy.data.fetcher import fetch_syn_data
    from dipy.io.image import load_nifti
    from dipy.align.imaffine import (transform_centers_of_mass,
                                     AffineMap,
                                     MutualInformationMetric,
                                     AffineRegistration)
    from dipy.align.transforms import (TranslationTransform3D,
                                       RigidTransform3D,
                                       AffineTransform3D)








.. GENERATED FROM PYTHON SOURCE LINES 31-33

Let's fetch two b0 volumes, the static image will be the b0 from the Stanford
HARDI dataset

.. GENERATED FROM PYTHON SOURCE LINES 33-42

.. code-block:: default



    files, folder = fetch_stanford_hardi()
    static_data, static_affine, static_img = load_nifti(
                                                pjoin(folder, 'HARDI150.nii.gz'),
                                                return_img=True)
    static = np.squeeze(static_data)[..., 0]
    static_grid2world = static_affine








.. GENERATED FROM PYTHON SOURCE LINES 43-44

Now the moving image

.. GENERATED FROM PYTHON SOURCE LINES 44-53

.. code-block:: default



    files, folder2 = fetch_syn_data()
    moving_data, moving_affine, moving_img = load_nifti(
                                                pjoin(folder2, 'b0.nii.gz'),
                                                return_img=True)
    moving = moving_data
    moving_grid2world = moving_affine








.. GENERATED FROM PYTHON SOURCE LINES 54-59

We can see that the images are far from aligned by drawing one on top of
the other. The images don't even have the same number of voxels, so in order
to draw one on top of the other we need to resample the moving image on a grid
of the same dimensions as the static image, we can do this by "transforming"
the moving image using an identity transform

.. GENERATED FROM PYTHON SOURCE LINES 59-73

.. code-block:: default



    identity = np.eye(4)
    affine_map = AffineMap(identity,
                           static.shape, static_grid2world,
                           moving.shape, moving_grid2world)
    resampled = affine_map.transform(moving)
    regtools.overlay_slices(static, resampled, None, 0,
                            "Static", "Moving", "resampled_0.png")
    regtools.overlay_slices(static, resampled, None, 1,
                            "Static", "Moving", "resampled_1.png")
    regtools.overlay_slices(static, resampled, None, 2,
                            "Static", "Moving", "resampled_2.png")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_001.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_001.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_002.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_002.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_003.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_003.png
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 74-82

.. figure:: resampled_0.png
   :align: center
.. figure:: resampled_1.png
   :align: center
.. figure:: resampled_2.png
   :align: center

   Input images before alignment.

.. GENERATED FROM PYTHON SOURCE LINES 85-87

We can obtain a very rough (and fast) registration by just aligning the centers
of mass of the two images

.. GENERATED FROM PYTHON SOURCE LINES 87-92

.. code-block:: default



    c_of_mass = transform_centers_of_mass(static, static_grid2world,
                                          moving, moving_grid2world)








.. GENERATED FROM PYTHON SOURCE LINES 93-96

We can now transform the moving image and draw it on top of the static image,
registration is not likely to be good, but at least they will occupy roughly
the same space

.. GENERATED FROM PYTHON SOURCE LINES 96-106

.. code-block:: default



    transformed = c_of_mass.transform(moving)
    regtools.overlay_slices(static, transformed, None, 0,
                            "Static", "Transformed", "transformed_com_0.png")
    regtools.overlay_slices(static, transformed, None, 1,
                            "Static", "Transformed", "transformed_com_1.png")
    regtools.overlay_slices(static, transformed, None, 2,
                            "Static", "Transformed", "transformed_com_2.png")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_004.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_004.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_005.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_005.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_006.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_006.png
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 107-115

.. figure:: transformed_com_0.png
   :align: center
.. figure:: transformed_com_1.png
   :align: center
.. figure:: transformed_com_2.png
   :align: center

   Registration result by aligning the centers of mass of the images.

.. GENERATED FROM PYTHON SOURCE LINES 118-127

This was just a translation of the moving image towards the static image, now
we will refine it by looking for an affine transform. We first create the
similarity metric (Mutual Information) to be used. We need to specify the
number of bins to be used to discretize the joint and marginal probability
distribution functions (PDF), a typical value is 32. We also need to specify
the percentage (an integer in (0, 100]) of voxels to be used for computing the
PDFs, the most accurate registration will be obtained by using all voxels, but
it is also the most time-consuming choice. We specify full sampling by passing
None instead of an integer

.. GENERATED FROM PYTHON SOURCE LINES 127-133

.. code-block:: default



    nbins = 32
    sampling_prop = None
    metric = MutualInformationMetric(nbins, sampling_prop)








.. GENERATED FROM PYTHON SOURCE LINES 134-143

To avoid getting stuck at local optima, and to accelerate convergence, we use a
multi-resolution strategy (similar to ANTS [Avants11]_) by building a Gaussian
Pyramid. To have as much flexibility as possible, the user can specify how this
Gaussian Pyramid is built. First of all, we need to specify how many
resolutions we want to use. This is indirectly specified by just providing a
list of the number of iterations we want to perform at each resolution. Here we
will just specify 3 resolutions and a large number of iterations, 10000 at the
coarsest resolution, 1000 at the medium resolution and 100 at the finest. These
are the default settings

.. GENERATED FROM PYTHON SOURCE LINES 143-147

.. code-block:: default



    level_iters = [10000, 1000, 100]








.. GENERATED FROM PYTHON SOURCE LINES 148-151

To compute the Gaussian pyramid, the original image is first smoothed at each
level of the pyramid using a Gaussian kernel with the requested sigma. A good
initial choice is [3.0, 1.0, 0.0], this is the default

.. GENERATED FROM PYTHON SOURCE LINES 151-155

.. code-block:: default



    sigmas = [3.0, 1.0, 0.0]








.. GENERATED FROM PYTHON SOURCE LINES 156-162

Now we specify the sub-sampling factors. A good configuration is [4, 2, 1],
which means that, if the original image shape was (nx, ny, nz) voxels, then the
shape of the coarsest image will be about (nx//4, ny//4, nz//4), the shape in
the middle resolution will be about (nx//2, ny//2, nz//2) and the image at the
finest scale has the same size as the original image. This set of factors is
the default

.. GENERATED FROM PYTHON SOURCE LINES 162-166

.. code-block:: default



    factors = [4, 2, 1]








.. GENERATED FROM PYTHON SOURCE LINES 167-169

Now we go ahead and instantiate the registration class with the configuration
we just prepared

.. GENERATED FROM PYTHON SOURCE LINES 169-176

.. code-block:: default



    affreg = AffineRegistration(metric=metric,
                                level_iters=level_iters,
                                sigmas=sigmas,
                                factors=factors)








.. GENERATED FROM PYTHON SOURCE LINES 177-188

Using AffineRegistration we can register our images in as many stages as we
want, providing previous results as initialization for the next (the same logic
as in ANTS). The reason why it is useful is that registration is a non-convex
optimization problem (it may have more than one local optima), which means that
it is very important to initialize as close to the solution as possible. For
example, let's start with our (previously computed) rough transformation
aligning the centers of mass of our images, and then refine it in three stages.
First look for an optimal translation. The dictionary regtransforms contains
all available transforms, we obtain one of them by providing its name and the
dimension (either 2 or 3) of the image we are working with (since we are
aligning volumes, the dimension is 3)

.. GENERATED FROM PYTHON SOURCE LINES 188-197

.. code-block:: default



    transform = TranslationTransform3D()
    params0 = None
    starting_affine = c_of_mass.affine
    translation = affreg.optimize(static, moving, transform, params0,
                                  static_grid2world, moving_grid2world,
                                  starting_affine=starting_affine)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Optimizing level 2 [max iter: 10000]
    Optimizing level 1 [max iter: 1000]
    Optimizing level 0 [max iter: 100]




.. GENERATED FROM PYTHON SOURCE LINES 198-200

If we look at the result, we can see that this translation is much better than
simply aligning the centers of mass

.. GENERATED FROM PYTHON SOURCE LINES 200-210

.. code-block:: default



    transformed = translation.transform(moving)
    regtools.overlay_slices(static, transformed, None, 0,
                            "Static", "Transformed", "transformed_trans_0.png")
    regtools.overlay_slices(static, transformed, None, 1,
                            "Static", "Transformed", "transformed_trans_1.png")
    regtools.overlay_slices(static, transformed, None, 2,
                            "Static", "Transformed", "transformed_trans_2.png")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_007.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_007.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_008.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_008.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_009.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_009.png
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 211-220

.. figure:: transformed_trans_0.png
   :align: center
.. figure:: transformed_trans_1.png
   :align: center
.. figure:: transformed_trans_2.png
   :align: center

   Registration result by translating the moving image, using
   Mutual Information.

.. GENERATED FROM PYTHON SOURCE LINES 223-225

Now let's refine with a rigid transform (this may even modify our previously
found optimal translation)

.. GENERATED FROM PYTHON SOURCE LINES 225-234

.. code-block:: default



    transform = RigidTransform3D()
    params0 = None
    starting_affine = translation.affine
    rigid = affreg.optimize(static, moving, transform, params0,
                            static_grid2world, moving_grid2world,
                            starting_affine=starting_affine)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Optimizing level 2 [max iter: 10000]
    Optimizing level 1 [max iter: 1000]
    Optimizing level 0 [max iter: 100]




.. GENERATED FROM PYTHON SOURCE LINES 235-236

This produces a slight rotation, and the images are now better aligned

.. GENERATED FROM PYTHON SOURCE LINES 236-246

.. code-block:: default



    transformed = rigid.transform(moving)
    regtools.overlay_slices(static, transformed, None, 0,
                            "Static", "Transformed", "transformed_rigid_0.png")
    regtools.overlay_slices(static, transformed, None, 1,
                            "Static", "Transformed", "transformed_rigid_1.png")
    regtools.overlay_slices(static, transformed, None, 2,
                            "Static", "Transformed", "transformed_rigid_2.png")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_010.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_010.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_011.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_011.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_012.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_012.png
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 247-255

.. figure:: transformed_rigid_0.png
   :align: center
.. figure:: transformed_rigid_1.png
   :align: center
.. figure:: transformed_rigid_2.png
   :align: center

   Registration result with a rigid transform, using Mutual Information.

.. GENERATED FROM PYTHON SOURCE LINES 258-261

Finally, let's refine with a full affine transform (translation, rotation, scale
and shear), it is safer to fit more degrees of freedom now since we must be
very close to the optimal transform

.. GENERATED FROM PYTHON SOURCE LINES 261-270

.. code-block:: default



    transform = AffineTransform3D()
    params0 = None
    starting_affine = rigid.affine
    affine = affreg.optimize(static, moving, transform, params0,
                             static_grid2world, moving_grid2world,
                             starting_affine=starting_affine)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Optimizing level 2 [max iter: 10000]
    Optimizing level 1 [max iter: 1000]
    Optimizing level 0 [max iter: 100]




.. GENERATED FROM PYTHON SOURCE LINES 271-272

This results in a slight shear and scale

.. GENERATED FROM PYTHON SOURCE LINES 272-282

.. code-block:: default



    transformed = affine.transform(moving)
    regtools.overlay_slices(static, transformed, None, 0,
                            "Static", "Transformed", "transformed_affine_0.png")
    regtools.overlay_slices(static, transformed, None, 1,
                            "Static", "Transformed", "transformed_affine_1.png")
    regtools.overlay_slices(static, transformed, None, 2,
                            "Static", "Transformed", "transformed_affine_2.png")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_013.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_013.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_014.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_014.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_015.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_015.png
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 283-292

.. figure:: transformed_affine_0.png
   :align: center
.. figure:: transformed_affine_1.png
   :align: center
.. figure:: transformed_affine_2.png
   :align: center

   Registration result with an affine transform, using Mutual Information.


.. GENERATED FROM PYTHON SOURCE LINES 295-296

Now, let's repeat this process with a simplified functional interface:

.. GENERATED FROM PYTHON SOURCE LINES 296-300

.. code-block:: default



    from dipy.align import affine_registration, register_dwi_to_template








.. GENERATED FROM PYTHON SOURCE LINES 301-303

This interface constructs a pipeline of operations from a given list of
transformations.

.. GENERATED FROM PYTHON SOURCE LINES 303-307

.. code-block:: default



    pipeline = ["center_of_mass", "translation", "rigid", "affine"]








.. GENERATED FROM PYTHON SOURCE LINES 308-313

And then applies the transformations in the pipeline on the input (from left to
right) with a call to an `affine_registration` function, which takes optional
settings for things like the iterations, sigmas and factors. The pipeline must
be a list of strings with one or more of the following transformations:
center_of_mass, translation, rigid, rigid_isoscaling, rigid_scaling and affine.

.. GENERATED FROM PYTHON SOURCE LINES 313-335

.. code-block:: default



    xformed_img, reg_affine = affine_registration(
        moving,
        static,
        moving_affine=moving_affine,
        static_affine=static_affine,
        nbins=32,
        metric='MI',
        pipeline=pipeline,
        level_iters=level_iters,
        sigmas=sigmas,
        factors=factors)

    regtools.overlay_slices(static, xformed_img, None, 0,
                            "Static", "Transformed", "xformed_affine_0.png")
    regtools.overlay_slices(static, xformed_img, None, 1,
                            "Static", "Transformed", "xformed_affine_1.png")
    regtools.overlay_slices(static, xformed_img, None, 2,
                            "Static", "Transformed", "xformed_affine_2.png")





.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_016.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_016.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_017.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_017.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_018.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_018.png
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Optimizing level 2 [max iter: 10000]
    Optimizing level 1 [max iter: 1000]
    Optimizing level 0 [max iter: 100]
    Optimizing level 2 [max iter: 10000]
    Optimizing level 1 [max iter: 1000]
    Optimizing level 0 [max iter: 100]
    Optimizing level 2 [max iter: 10000]
    Optimizing level 1 [max iter: 1000]
    Optimizing level 0 [max iter: 100]

    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 336-345

.. figure:: xformed_affine_0.png
   :align: center
.. figure:: xformed_affine_1.png
   :align: center
.. figure:: xformed_affine_2.png
   :align: center

   Registration result with an affine transform, using functional interface.


.. GENERATED FROM PYTHON SOURCE LINES 349-355

Alternatively, you can also use the `register_dwi_to_template` function that
needs to also know about the gradient table of the DWI data, provided as a
tuple of (bvals_file, bvecs_file). In this case, we are going to move the
diffusion data to the B0 image (the opposite of the previous examples), which
reverses what is the "moving" image and what is "static".


.. GENERATED FROM PYTHON SOURCE LINES 355-379

.. code-block:: default



    xformed_dwi, reg_affine = register_dwi_to_template(
        dwi=static_img,
        gtab=(pjoin(folder, 'HARDI150.bval'),
              pjoin(folder, 'HARDI150.bvec')),
        template=moving_img,
        reg_method="aff",
        nbins=32,
        metric='MI',
        pipeline=pipeline,
        level_iters=level_iters,
        sigmas=sigmas,
        factors=factors)

    regtools.overlay_slices(moving, xformed_dwi, None, 0,
                            "Static", "Transformed", "xformed_dwi_0.png")
    regtools.overlay_slices(moving, xformed_dwi, None, 1,
                            "Static", "Transformed", "xformed_dwi_1.png")
    regtools.overlay_slices(moving, xformed_dwi, None, 2,
                            "Static", "Transformed", "xformed_dwi_2.png")






.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_019.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_019.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_020.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_020.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_021.png
          :alt: affine registration 3d
          :srcset: /examples_built/20_registration/images/sphx_glr_affine_registration_3d_021.png
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Optimizing level 2 [max iter: 10000]
    Optimizing level 1 [max iter: 1000]
    Optimizing level 0 [max iter: 100]
    Optimizing level 2 [max iter: 10000]
    Optimizing level 1 [max iter: 1000]
    Optimizing level 0 [max iter: 100]
    Optimizing level 2 [max iter: 10000]
    Optimizing level 1 [max iter: 1000]
    Optimizing level 0 [max iter: 100]

    <Figure size 640x480 with 3 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 380-399

.. figure:: xformed_dwi_0.png
   :align: center
.. figure:: xformed_dwi_1.png
   :align: center
.. figure:: xformed_dwi_2.png
   :align: center

   Same again, using the `dwi_to_template` functional interface.


.. [Mattes03] Mattes, D., Haynor, D. R., Vesselle, H., Lewellen, T. K.,
              Eubank, W. (2003). PET-CT image registration in the chest using
              free-form deformations. IEEE Transactions on Medical Imaging,
              22(1), 120-8.
.. [Avants11] Avants, B. B., Tustison, N., & Song, G. (2011). Advanced
              Normalization Tools (ANTS), 1-35.

.. include:: ../links_names.inc



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  53.718 seconds)


.. _sphx_glr_download_examples_built_20_registration_affine_registration_3d.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: affine_registration_3d.py <affine_registration_3d.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: affine_registration_3d.ipynb <affine_registration_3d.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_

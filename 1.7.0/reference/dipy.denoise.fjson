{"parents": [{"link": "../../documentation/", "title": "Documentation"}, {"link": "../", "title": "API Reference"}], "prev": {"link": "../dipy.data/", "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">data</span></code>"}, "next": {"link": "../dipy.direction/", "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">direction</span></code>"}, "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise</span></code>", "meta": {}, "body": "<section id=\"module-dipy.denoise\">\n<span id=\"denoise\"></span><h1><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise\" title=\"Permalink to this heading\">\u00b6</a></h1>\n<table class=\"autosummary longtable docutils align-default\">\n<tbody>\n</tbody>\n</table>\n<section id=\"module-dipy.denoise.adaptive_soft_matching\">\n<span id=\"module-denoise-adaptive-soft-matching\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.adaptive_soft_matching</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.adaptive_soft_matching\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<table class=\"autosummary longtable docutils align-default\">\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\" title=\"dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">adaptive_soft_matching</span></code></a>(ima,\u00a0fimau,\u00a0fimao,\u00a0sigma)</p></td>\n<td><p>Adaptive Soft Coefficient Matching</p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"module-dipy.denoise.gibbs\">\n<span id=\"module-denoise-gibbs\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.gibbs</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.gibbs\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<table class=\"autosummary longtable docutils align-default\">\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.gibbs.gibbs_removal\" title=\"dipy.denoise.gibbs.gibbs_removal\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gibbs_removal</span></code></a>(vol[,\u00a0slice_axis,\u00a0n_points,\u00a0...])</p></td>\n<td><p>Suppresses Gibbs ringing artefacts of images volumes.</p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"module-dipy.denoise.localpca\">\n<span id=\"module-denoise-localpca\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.localpca</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.localpca\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<table class=\"autosummary longtable docutils align-default\">\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.localpca.genpca\" title=\"dipy.denoise.localpca.genpca\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">genpca</span></code></a>(arr[,\u00a0sigma,\u00a0mask,\u00a0patch_radius,\u00a0...])</p></td>\n<td><p>General function to perform PCA-based denoising of diffusion datasets.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.localpca.localpca\" title=\"dipy.denoise.localpca.localpca\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">localpca</span></code></a>(arr[,\u00a0sigma,\u00a0mask,\u00a0patch_radius,\u00a0...])</p></td>\n<td><p>Performs local PCA denoising according to Manjon et al. <a href=\"#id59\"><span class=\"problematic\" id=\"id1\">[1]_</span></a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.localpca.mppca\" title=\"dipy.denoise.localpca.mppca\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mppca</span></code></a>(arr[,\u00a0mask,\u00a0patch_radius,\u00a0pca_method,\u00a0...])</p></td>\n<td><p>Performs PCA-based denoising using the Marcenko-Pastur distribution <a href=\"#id60\"><span class=\"problematic\" id=\"id2\">[1]_</span></a>.</p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"module-dipy.denoise.nlmeans\">\n<span id=\"module-denoise-nlmeans\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.nlmeans</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.nlmeans\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<table class=\"autosummary longtable docutils align-default\">\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.nlmeans.nlmeans\" title=\"dipy.denoise.nlmeans.nlmeans\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nlmeans</span></code></a>(arr,\u00a0sigma[,\u00a0mask,\u00a0patch_radius,\u00a0...])</p></td>\n<td><p>Non-local means for denoising 3D and 4D images</p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"module-dipy.denoise.noise_estimate\">\n<span id=\"module-denoise-noise-estimate\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.noise_estimate</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.noise_estimate\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<table class=\"autosummary longtable docutils align-default\">\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.piesno\" title=\"dipy.denoise.noise_estimate.piesno\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">piesno</span></code></a>(data,\u00a0N[,\u00a0alpha,\u00a0l,\u00a0itermax,\u00a0eps,\u00a0...])</p></td>\n<td><p>Probabilistic Identification and Estimation of Noise (PIESNO).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.estimate_sigma\" title=\"dipy.denoise.noise_estimate.estimate_sigma\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">estimate_sigma</span></code></a>(arr[,\u00a0...])</p></td>\n<td><p>Standard deviation estimation from local patches</p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"module-dipy.denoise.non_local_means\">\n<span id=\"module-denoise-non-local-means\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.non_local_means</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.non_local_means\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<table class=\"autosummary longtable docutils align-default\">\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.non_local_means.non_local_means\" title=\"dipy.denoise.non_local_means.non_local_means\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">non_local_means</span></code></a>(arr,\u00a0sigma[,\u00a0mask,\u00a0...])</p></td>\n<td><p>Non-local means for denoising 3D and 4D images, using</p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"module-dipy.denoise.patch2self\">\n<span id=\"module-denoise-patch2self\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.patch2self</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.patch2self\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<table class=\"autosummary longtable docutils align-default\">\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.patch2self.patch2self\" title=\"dipy.denoise.patch2self.patch2self\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">patch2self</span></code></a>(data,\u00a0bvals[,\u00a0patch_radius,\u00a0...])</p></td>\n<td><p>Patch2Self Denoiser.</p></td>\n</tr>\n</tbody>\n</table>\n<section id=\"adaptive-soft-matching\">\n<h3>adaptive_soft_matching<a class=\"headerlink\" href=\"#adaptive-soft-matching\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\">\n<span class=\"sig-prename descclassname\"><span class=\"pre\">dipy.denoise.adaptive_soft_matching.</span></span><span class=\"sig-name descname\"><span class=\"pre\">adaptive_soft_matching</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">ima</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">fimau</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">fimao</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">sigma</span></span></em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Adaptive Soft Coefficient Matching</p>\n<p>Combines two filtered 3D-images at different resolutions and the original\nimage. Returns the resulting combined image.</p>\n<section id=\"parameters\">\n<h4>Parameters<a class=\"headerlink\" href=\"#parameters\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<p>ima : the original (not filtered) image\nfimau : 3D double array,</p>\n<blockquote>\n<div><p>filtered image with optimized non-local means using a small block\n(suggested:3x3), which corresponds to a \u201chigh resolution\u201d filter.</p>\n</div></blockquote>\n<dl class=\"simple\">\n<dt>fimao<span class=\"classifier\">3D double array,</span></dt><dd><p>filtered image with optimized non-local means using a small block\n(suggested:5x5), which corresponds to a \u201clow resolution\u201d filter.</p>\n</dd>\n<dt>sigma<span class=\"classifier\">the estimated standard deviation of the Gaussian random variables</span></dt><dd><p>that explain the rician noise. Note: In P. Coupe et al. the\nrician noise was simulated as sqrt((f+x)^2 + (y)^2) where f is\nthe pixel value and x and y are independent realizations of a\nrandom variable with Normal distribution, with mean=0 and\nstandard deviation=h</p>\n</dd>\n</dl>\n</section>\n<section id=\"returns\">\n<h4>Returns<a class=\"headerlink\" href=\"#returns\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>fima<span class=\"classifier\">3D double array</span></dt><dd><p>output denoised array which is of the same shape as that of\nthe input</p>\n</dd>\n</dl>\n</section>\n<section id=\"references\">\n<h4>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<div role=\"list\" class=\"citation-list\">\n<div class=\"citation\" id=\"coupe11\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>Coupe11<span class=\"fn-bracket\">]</span></span>\n<p>Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.\n\u201cMultiresolution Non-Local Means Filter for 3D MR Image\nDenoising\u201d IET Image Processing, Institution of Engineering\nand Technology,\n2011</p>\n</div>\n</div>\n</section>\n</dd></dl>\n\n</section>\n<section id=\"gibbs-removal\">\n<h3>gibbs_removal<a class=\"headerlink\" href=\"#gibbs-removal\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"dipy.denoise.gibbs.gibbs_removal\">\n<span class=\"sig-prename descclassname\"><span class=\"pre\">dipy.denoise.gibbs.</span></span><span class=\"sig-name descname\"><span class=\"pre\">gibbs_removal</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">vol</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">slice_axis</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">2</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">n_points</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">3</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">inplace</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">True</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">num_processes</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">1</span></span></em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.gibbs.gibbs_removal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Suppresses Gibbs ringing artefacts of images volumes.</p>\n<section id=\"id3\">\n<h4>Parameters<a class=\"headerlink\" href=\"#id3\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>vol<span class=\"classifier\">ndarray ([X, Y]), ([X, Y, Z]) or ([X, Y, Z, g])</span></dt><dd><p>Matrix containing one volume (3D) or multiple (4D) volumes of images.</p>\n</dd>\n<dt>slice_axis<span class=\"classifier\">int (0, 1, or 2)</span></dt><dd><p>Data axis corresponding to the number of acquired slices.\nDefault is set to the third axis.</p>\n</dd>\n<dt>n_points<span class=\"classifier\">int, optional</span></dt><dd><p>Number of neighbour points to access local TV (see note).\nDefault is set to 3.</p>\n</dd>\n<dt>inplace<span class=\"classifier\">bool, optional</span></dt><dd><p>If True, the input data is replaced with results. Otherwise, returns\na new array.\nDefault is set to True.</p>\n</dd>\n<dt>num_processes<span class=\"classifier\">int or None, optional</span></dt><dd><p>Split the calculation to a pool of children processes. This only\napplies to 3D or 4D <cite>data</cite> arrays. Default is 1. If &lt; 0 the maximal\nnumber of cores minus <code class=\"docutils literal notranslate\"><span class=\"pre\">num_processes</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code> is used (enter -1 to use\nas many cores as possible). 0 raises an error.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id4\">\n<h4>Returns<a class=\"headerlink\" href=\"#id4\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>vol<span class=\"classifier\">ndarray ([X, Y]), ([X, Y, Z]) or ([X, Y, Z, g])</span></dt><dd><p>Matrix containing one volume (3D) or multiple (4D) volumes of corrected\nimages.</p>\n</dd>\n</dl>\n</section>\n<section id=\"notes\">\n<h4>Notes<a class=\"headerlink\" href=\"#notes\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<p>For 4D matrix last element should always correspond to the number of\ndiffusion gradient directions.</p>\n</section>\n<section id=\"id5\">\n<h4>References<a class=\"headerlink\" href=\"#id5\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<p>Please cite the following articles\n.. [1] Neto Henriques, R., 2018. Advanced Methods for Diffusion MRI Data</p>\n<blockquote>\n<div><p>Analysis and their Application to the Healthy Ageing Brain\n(Doctoral thesis). <a class=\"reference external\" href=\"https://doi.org/10.17863/CAM.29356\">https://doi.org/10.17863/CAM.29356</a></p>\n</div></blockquote>\n<aside class=\"footnote-list brackets\">\n<aside class=\"footnote brackets\" id=\"id6\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>2<span class=\"fn-bracket\">]</span></span>\n<p>Kellner E, Dhital B, Kiselev VG, Reisert M. Gibbs-ringing artifact\nremoval based on local subvoxel-shifts. Magn Reson Med. 2016\ndoi: 10.1002/mrm.26054.</p>\n</aside>\n</aside>\n</section>\n</dd></dl>\n\n</section>\n<section id=\"genpca\">\n<h3>genpca<a class=\"headerlink\" href=\"#genpca\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"dipy.denoise.localpca.genpca\">\n<span class=\"sig-prename descclassname\"><span class=\"pre\">dipy.denoise.localpca.</span></span><span class=\"sig-name descname\"><span class=\"pre\">genpca</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">arr</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">sigma</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">mask</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">patch_radius</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">2</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">pca_method</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">'eig'</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">tau_factor</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">return_sigma</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">out_dtype</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">suppress_warning</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.localpca.genpca\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>General function to perform PCA-based denoising of diffusion datasets.</p>\n<section id=\"id7\">\n<h4>Parameters<a class=\"headerlink\" href=\"#id7\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl>\n<dt>arr<span class=\"classifier\">4D array</span></dt><dd><p>Array of data to be denoised. The dimensions are (X, Y, Z, N), where N\nare the diffusion gradient directions. The first 3 dimension must have\nsize &gt;= 2 * patch_radius + 1 or size = 1.</p>\n</dd>\n<dt>sigma<span class=\"classifier\">float or 3D array (optional)</span></dt><dd><p>Standard deviation of the noise estimated from the data. If no sigma\nis given, this will be estimated based on random matrix theory\n<a href=\"#id61\"><span class=\"problematic\" id=\"id8\">[1]_</span></a>,[2]_</p>\n</dd>\n<dt>mask<span class=\"classifier\">3D boolean array (optional)</span></dt><dd><p>A mask with voxels that are true inside the brain and false outside of\nit. The function denoises within the true part and returns zeros\noutside of those voxels.</p>\n</dd>\n<dt>patch_radius<span class=\"classifier\">int or 1D array (optional)</span></dt><dd><p>The radius of the local patch to be taken around each voxel (in\nvoxels). E.g. patch_radius=2 gives 5x5x5 patches.</p>\n</dd>\n<dt>pca_method<span class=\"classifier\">\u2018eig\u2019 or \u2018svd\u2019 (optional)</span></dt><dd><p>Use either eigenvalue decomposition (eig) or singular value\ndecomposition (svd) for principal component analysis. The default\nmethod is \u2018eig\u2019 which is faster. However, occasionally \u2018svd\u2019 might be\nmore accurate.</p>\n</dd>\n<dt>tau_factor<span class=\"classifier\">float (optional)</span></dt><dd><p>Thresholding of PCA eigenvalues is done by nulling out eigenvalues that\nare smaller than:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\tau = (\\tau_{factor} \\sigma)^2\\]</div>\n<p>tau_{factor} can be set to a predefined values (e.g. tau_{factor} =\n2.3 <a class=\"footnote-reference brackets\" href=\"#id14\" id=\"id9\" role=\"doc-noteref\"><span class=\"fn-bracket\">[</span>3<span class=\"fn-bracket\">]</span></a>), or automatically calculated using random matrix theory\n(in case that tau_{factor} is set to None).</p>\n</dd>\n<dt>return_sigma<span class=\"classifier\">bool (optional)</span></dt><dd><p>If true, the Standard deviation of the noise will be returned.</p>\n</dd>\n<dt>out_dtype<span class=\"classifier\">str or dtype (optional)</span></dt><dd><p>The dtype for the output array. Default: output has the same dtype as\nthe input.</p>\n</dd>\n<dt>suppress_warning<span class=\"classifier\">bool (optional)</span></dt><dd><p>If true, suppress warning caused by patch_size &lt; arr.shape[-1].</p>\n</dd>\n</dl>\n</section>\n<section id=\"id10\">\n<h4>Returns<a class=\"headerlink\" href=\"#id10\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>denoised_arr<span class=\"classifier\">4D array</span></dt><dd><p>This is the denoised array of the same size as that of the input data,\nclipped to non-negative values.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id11\">\n<h4>References<a class=\"headerlink\" href=\"#id11\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<aside class=\"footnote-list brackets\">\n<aside class=\"footnote brackets\" id=\"id12\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>1<span class=\"fn-bracket\">]</span></span>\n<p>Veraart J, Novikov DS, Christiaens D, Ades-aron B, Sijbers,\nFieremans E, 2016. Denoising of Diffusion MRI using random matrix\ntheory. Neuroimage 142:394-406.\ndoi: 10.1016/j.neuroimage.2016.08.016</p>\n</aside>\n<aside class=\"footnote brackets\" id=\"id13\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>2<span class=\"fn-bracket\">]</span></span>\n<p>Veraart J, Fieremans E, Novikov DS. 2016. Diffusion MRI noise\nmapping using random matrix theory. Magnetic Resonance in Medicine.\ndoi: 10.1002/mrm.26059.</p>\n</aside>\n<aside class=\"footnote brackets\" id=\"id14\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id9\">3</a><span class=\"fn-bracket\">]</span></span>\n<p>Manjon JV, Coupe P, Concha L, Buades A, Collins DL (2013)\nDiffusion Weighted Image Denoising Using Overcomplete Local\nPCA. PLoS ONE 8(9): e73021.\n<a class=\"reference external\" href=\"https://doi.org/10.1371/journal.pone.0073021\">https://doi.org/10.1371/journal.pone.0073021</a></p>\n</aside>\n</aside>\n</section>\n</dd></dl>\n\n</section>\n<section id=\"localpca\">\n<h3>localpca<a class=\"headerlink\" href=\"#localpca\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"dipy.denoise.localpca.localpca\">\n<span class=\"sig-prename descclassname\"><span class=\"pre\">dipy.denoise.localpca.</span></span><span class=\"sig-name descname\"><span class=\"pre\">localpca</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">arr</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">sigma</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">mask</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">patch_radius</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">2</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">gtab</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">patch_radius_sigma</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">1</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">pca_method</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">'eig'</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">tau_factor</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">2.3</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">return_sigma</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">correct_bias</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">True</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">out_dtype</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">suppress_warning</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.localpca.localpca\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Performs local PCA denoising according to Manjon et al. <a href=\"#id62\"><span class=\"problematic\" id=\"id15\">[1]_</span></a>.</p>\n<section id=\"id16\">\n<h4>Parameters<a class=\"headerlink\" href=\"#id16\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl>\n<dt>arr<span class=\"classifier\">4D array</span></dt><dd><p>Array of data to be denoised. The dimensions are (X, Y, Z, N), where N\nare the diffusion gradient directions.</p>\n</dd>\n<dt>sigma<span class=\"classifier\">float or 3D array (optional)</span></dt><dd><p>Standard deviation of the noise estimated from the data. If not given,\ncalculate using method in <a href=\"#id63\"><span class=\"problematic\" id=\"id17\">[1]_</span></a>.</p>\n</dd>\n<dt>mask<span class=\"classifier\">3D boolean array (optional)</span></dt><dd><p>A mask with voxels that are true inside the brain and false outside of\nit. The function denoises within the true part and returns zeros\noutside of those voxels.</p>\n</dd>\n<dt>patch_radius<span class=\"classifier\">int or 1D array (optional)</span></dt><dd><p>The radius of the local patch to be taken around each voxel (in\nvoxels). E.g. patch_radius=2 gives 5x5x5 patches.</p>\n</dd>\n<dt>gtab: gradient table object (optional if sigma is provided)</dt><dd><p>gradient information for the data gives us the bvals and bvecs of\ndiffusion data, which is needed to calculate noise level if sigma is\nnot provided.</p>\n</dd>\n<dt>patch_radius_sigma<span class=\"classifier\">int (optional)</span></dt><dd><p>The radius of the local patch to be taken around each voxel (in\nvoxels) for estimating sigma. E.g. patch_radius_sigma=2 gives\n5x5x5 patches.</p>\n</dd>\n<dt>pca_method<span class=\"classifier\">\u2018eig\u2019 or \u2018svd\u2019 (optional)</span></dt><dd><p>Use either eigenvalue decomposition (eig) or singular value\ndecomposition (svd) for principal component analysis. The default\nmethod is \u2018eig\u2019 which is faster. However, occasionally \u2018svd\u2019 might be\nmore accurate.</p>\n</dd>\n<dt>tau_factor<span class=\"classifier\">float (optional)</span></dt><dd><p>Thresholding of PCA eigenvalues is done by nulling out eigenvalues that\nare smaller than:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\tau = (\\tau_{factor} \\sigma)^2\\]</div>\n<p>tau_{factor} can be change to adjust the relationship between the\nnoise standard deviation and the threshold tau. If tau_{factor} is\nset to None, it will be automatically calculated using the\nMarcenko-Pastur distribution <a href=\"#id64\"><span class=\"problematic\" id=\"id18\">[2]_</span></a>. Default: 2.3 according to <a href=\"#id65\"><span class=\"problematic\" id=\"id19\">[1]_</span></a>.</p>\n</dd>\n<dt>return_sigma<span class=\"classifier\">bool (optional)</span></dt><dd><p>If true, a noise standard deviation estimate based on the\nMarcenko-Pastur distribution is returned <a href=\"#id66\"><span class=\"problematic\" id=\"id20\">[2]_</span></a>.</p>\n</dd>\n<dt>correct_bias<span class=\"classifier\">bool (optional)</span></dt><dd><p>Whether to correct for bias due to Rician noise. This is an\nimplementation of equation 8 in <a href=\"#id67\"><span class=\"problematic\" id=\"id21\">[1]_</span></a>.</p>\n</dd>\n<dt>out_dtype<span class=\"classifier\">str or dtype (optional)</span></dt><dd><p>The dtype for the output array. Default: output has the same dtype as\nthe input.</p>\n</dd>\n<dt>suppress_warning<span class=\"classifier\">bool (optional)</span></dt><dd><p>If true, suppress warning caused by patch_size &lt; arr.shape[-1].</p>\n</dd>\n</dl>\n</section>\n<section id=\"id22\">\n<h4>Returns<a class=\"headerlink\" href=\"#id22\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>denoised_arr<span class=\"classifier\">4D array</span></dt><dd><p>This is the denoised array of the same size as that of the input data,\nclipped to non-negative values</p>\n</dd>\n</dl>\n</section>\n<section id=\"id23\">\n<h4>References<a class=\"headerlink\" href=\"#id23\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<aside class=\"footnote-list brackets\">\n<aside class=\"footnote brackets\" id=\"id24\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>1<span class=\"fn-bracket\">]</span></span>\n<p>Manjon JV, Coupe P, Concha L, Buades A, Collins DL (2013)\nDiffusion Weighted Image Denoising Using Overcomplete Local\nPCA. PLoS ONE 8(9): e73021.\n<a class=\"reference external\" href=\"https://doi.org/10.1371/journal.pone.0073021\">https://doi.org/10.1371/journal.pone.0073021</a></p>\n</aside>\n<aside class=\"footnote brackets\" id=\"id25\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>2<span class=\"fn-bracket\">]</span></span>\n<p>Veraart J, Novikov DS, Christiaens D, Ades-aron B, Sijbers,\nFieremans E, 2016. Denoising of Diffusion MRI using random matrix\ntheory. Neuroimage 142:394-406.\ndoi: 10.1016/j.neuroimage.2016.08.016</p>\n</aside>\n</aside>\n</section>\n</dd></dl>\n\n</section>\n<section id=\"mppca\">\n<h3>mppca<a class=\"headerlink\" href=\"#mppca\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"dipy.denoise.localpca.mppca\">\n<span class=\"sig-prename descclassname\"><span class=\"pre\">dipy.denoise.localpca.</span></span><span class=\"sig-name descname\"><span class=\"pre\">mppca</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">arr</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">mask</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">patch_radius</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">2</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">pca_method</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">'eig'</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">return_sigma</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">out_dtype</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">suppress_warning</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.localpca.mppca\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Performs PCA-based denoising using the Marcenko-Pastur\ndistribution <a href=\"#id68\"><span class=\"problematic\" id=\"id26\">[1]_</span></a>.</p>\n<section id=\"id27\">\n<h4>Parameters<a class=\"headerlink\" href=\"#id27\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>arr<span class=\"classifier\">4D array</span></dt><dd><p>Array of data to be denoised. The dimensions are (X, Y, Z, N), where N\nare the diffusion gradient directions.</p>\n</dd>\n<dt>mask<span class=\"classifier\">3D boolean array (optional)</span></dt><dd><p>A mask with voxels that are true inside the brain and false outside of\nit. The function denoises within the true part and returns zeros\noutside of those voxels.</p>\n</dd>\n<dt>patch_radius<span class=\"classifier\">int or 1D array (optional)</span></dt><dd><p>The radius of the local patch to be taken around each voxel (in\nvoxels). E.g. patch_radius=2 gives 5x5x5 patches.</p>\n</dd>\n<dt>pca_method<span class=\"classifier\">\u2018eig\u2019 or \u2018svd\u2019 (optional)</span></dt><dd><p>Use either eigenvalue decomposition (eig) or singular value\ndecomposition (svd) for principal component analysis. The default\nmethod is \u2018eig\u2019 which is faster. However, occasionally \u2018svd\u2019 might be\nmore accurate.</p>\n</dd>\n<dt>return_sigma<span class=\"classifier\">bool (optional)</span></dt><dd><p>If true, a noise standard deviation estimate based on the\nMarcenko-Pastur distribution is returned <a href=\"#id69\"><span class=\"problematic\" id=\"id28\">[2]_</span></a>.</p>\n</dd>\n<dt>out_dtype<span class=\"classifier\">str or dtype (optional)</span></dt><dd><p>The dtype for the output array. Default: output has the same dtype as\nthe input.</p>\n</dd>\n<dt>suppress_warning<span class=\"classifier\">bool (optional)</span></dt><dd><p>If true, suppress warning caused by patch_size &lt; arr.shape[-1].</p>\n</dd>\n</dl>\n</section>\n<section id=\"id29\">\n<h4>Returns<a class=\"headerlink\" href=\"#id29\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>denoised_arr<span class=\"classifier\">4D array</span></dt><dd><p>This is the denoised array of the same size as that of the input data,\nclipped to non-negative values</p>\n</dd>\n<dt>sigma<span class=\"classifier\">3D array (when return_sigma=True)</span></dt><dd><p>Estimate of the spatial varying standard deviation of the noise</p>\n</dd>\n</dl>\n</section>\n<section id=\"id30\">\n<h4>References<a class=\"headerlink\" href=\"#id30\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<aside class=\"footnote-list brackets\">\n<aside class=\"footnote brackets\" id=\"id31\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>1<span class=\"fn-bracket\">]</span></span>\n<p>Veraart J, Novikov DS, Christiaens D, Ades-aron B, Sijbers,\nFieremans E, 2016. Denoising of Diffusion MRI using random matrix\ntheory. Neuroimage 142:394-406.\ndoi: 10.1016/j.neuroimage.2016.08.016</p>\n</aside>\n<aside class=\"footnote brackets\" id=\"id32\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>2<span class=\"fn-bracket\">]</span></span>\n<p>Veraart J, Fieremans E, Novikov DS. 2016. Diffusion MRI noise\nmapping using random matrix theory. Magnetic Resonance in Medicine.\ndoi: 10.1002/mrm.26059.</p>\n</aside>\n</aside>\n</section>\n</dd></dl>\n\n</section>\n<section id=\"nlmeans\">\n<h3>nlmeans<a class=\"headerlink\" href=\"#nlmeans\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"dipy.denoise.nlmeans.nlmeans\">\n<span class=\"sig-prename descclassname\"><span class=\"pre\">dipy.denoise.nlmeans.</span></span><span class=\"sig-name descname\"><span class=\"pre\">nlmeans</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">arr</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">sigma</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">mask</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">patch_radius</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">1</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">block_radius</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">5</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">rician</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">True</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">num_threads</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.nlmeans.nlmeans\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Non-local means for denoising 3D and 4D images</p>\n<section id=\"id33\">\n<h4>Parameters<a class=\"headerlink\" href=\"#id33\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>arr<span class=\"classifier\">3D or 4D ndarray</span></dt><dd><p>The array to be denoised</p>\n</dd>\n</dl>\n<p>mask : 3D ndarray\nsigma : float or 3D array</p>\n<blockquote>\n<div><p>standard deviation of the noise estimated from the data</p>\n</div></blockquote>\n<dl class=\"simple\">\n<dt>patch_radius<span class=\"classifier\">int</span></dt><dd><p>patch size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">patch_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 1.</p>\n</dd>\n<dt>block_radius<span class=\"classifier\">int</span></dt><dd><p>block size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">block_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 5.</p>\n</dd>\n<dt>rician<span class=\"classifier\">boolean</span></dt><dd><p>If True the noise is estimated as Rician, otherwise Gaussian noise\nis assumed.</p>\n</dd>\n<dt>num_threads<span class=\"classifier\">int, optional</span></dt><dd><p>Number of threads to be used for OpenMP parallelization. If None\n(default) the value of OMP_NUM_THREADS environment variable is used\nif it is set, otherwise all available threads are used. If &lt; 0 the\nmaximal number of threads minus <a href=\"#id57\"><span class=\"problematic\" id=\"id58\">|num_threads + 1|</span></a> is used (enter -1 to\nuse as many threads as possible). 0 raises an error.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id34\">\n<h4>Returns<a class=\"headerlink\" href=\"#id34\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>denoised_arr<span class=\"classifier\">ndarray</span></dt><dd><p>the denoised <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code> which has the same shape as <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code>.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id35\">\n<h4>References<a class=\"headerlink\" href=\"#id35\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<div role=\"list\" class=\"citation-list\">\n<div class=\"citation\" id=\"descoteaux08\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>Descoteaux08<span class=\"fn-bracket\">]</span></span>\n<p>Descoteaux, Maxime and Wiest-Daessl\u00e9, Nicolas and Prima,\nSylvain and Barillot, Christian and Deriche, Rachid\nImpact of Rician Adapted Non-Local Means Filtering on\nHARDI, MICCAI 2008</p>\n</div>\n</div>\n</section>\n</dd></dl>\n\n</section>\n<section id=\"piesno\">\n<h3>piesno<a class=\"headerlink\" href=\"#piesno\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"dipy.denoise.noise_estimate.piesno\">\n<span class=\"sig-prename descclassname\"><span class=\"pre\">dipy.denoise.noise_estimate.</span></span><span class=\"sig-name descname\"><span class=\"pre\">piesno</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">data</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">N</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">alpha</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">0.01</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">l</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">100</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">itermax</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">100</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">eps</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">1e-05</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">return_mask</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.noise_estimate.piesno\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Probabilistic Identification and Estimation of Noise (PIESNO).</p>\n<section id=\"id36\">\n<h4>Parameters<a class=\"headerlink\" href=\"#id36\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>data<span class=\"classifier\">ndarray</span></dt><dd><p>The magnitude signals to analyse. The last dimension must contain the\nsame realisation of the volume, such as dMRI or fMRI data.</p>\n</dd>\n<dt>N<span class=\"classifier\">int</span></dt><dd><p>The number of phase array coils of the MRI scanner.\nIf your scanner does a SENSE reconstruction, ALWAYS use N=1, as the\nnoise profile is always Rician.\nIf your scanner does a GRAPPA reconstruction, set N as the number\nof phase array coils.</p>\n</dd>\n<dt>alpha<span class=\"classifier\">float</span></dt><dd><p>Probabilistic estimation threshold for the gamma function.</p>\n</dd>\n<dt>l<span class=\"classifier\">int</span></dt><dd><p>number of initial estimates for sigma to try.</p>\n</dd>\n<dt>itermax<span class=\"classifier\">int</span></dt><dd><p>Maximum number of iterations to execute if convergence\nis not reached.</p>\n</dd>\n<dt>eps<span class=\"classifier\">float</span></dt><dd><p>Tolerance for the convergence criterion. Convergence is\nreached if two subsequent estimates are smaller than eps.</p>\n</dd>\n<dt>return_mask<span class=\"classifier\">bool</span></dt><dd><p>If True, return a mask identifying all the pure noise voxel\nthat were found.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id37\">\n<h4>Returns<a class=\"headerlink\" href=\"#id37\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>sigma<span class=\"classifier\">float</span></dt><dd><p>The estimated standard deviation of the gaussian noise.</p>\n</dd>\n<dt>mask<span class=\"classifier\">ndarray (optional)</span></dt><dd><p>A boolean mask indicating the voxels identified as pure noise.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id38\">\n<h4>Notes<a class=\"headerlink\" href=\"#id38\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<p>This function assumes two things : 1. The data has a noisy, non-masked\nbackground and 2. The data is a repetition of the same measurements\nalong the last axis, i.e. dMRI or fMRI data, not structural data like\nT1/T2.</p>\n<p>This function processes the data slice by slice, as originally designed in\nthe paper. Use it to get a slice by slice estimation of the noise, as in\nspinal cord imaging for example.</p>\n</section>\n<section id=\"id39\">\n<h4>References<a class=\"headerlink\" href=\"#id39\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<aside class=\"footnote-list brackets\">\n<aside class=\"footnote brackets\" id=\"id40\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>1<span class=\"fn-bracket\">]</span></span>\n<p>Koay CG, Ozarslan E and Pierpaoli C.</p>\n</aside>\n</aside>\n<p>\u201cProbabilistic Identification and Estimation of Noise (PIESNO):\nA self-consistent approach and its applications in MRI.\u201d\nJournal of Magnetic Resonance 2009; 199: 94-103.</p>\n<aside class=\"footnote-list brackets\">\n<aside class=\"footnote brackets\" id=\"id41\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>2<span class=\"fn-bracket\">]</span></span>\n<p>Koay CG, Ozarslan E and Basser PJ.</p>\n</aside>\n</aside>\n<p>\u201cA signal transformational framework for breaking the noise floor\nand its applications in MRI.\u201d\nJournal of Magnetic Resonance 2009; 197: 108-119.</p>\n</section>\n</dd></dl>\n\n</section>\n<section id=\"estimate-sigma\">\n<h3>estimate_sigma<a class=\"headerlink\" href=\"#estimate-sigma\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"dipy.denoise.noise_estimate.estimate_sigma\">\n<span class=\"sig-prename descclassname\"><span class=\"pre\">dipy.denoise.noise_estimate.</span></span><span class=\"sig-name descname\"><span class=\"pre\">estimate_sigma</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">arr</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">disable_background_masking</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">N</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">0</span></span></em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.noise_estimate.estimate_sigma\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Standard deviation estimation from local patches</p>\n<section id=\"id42\">\n<h4>Parameters<a class=\"headerlink\" href=\"#id42\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>arr<span class=\"classifier\">3D or 4D ndarray</span></dt><dd><p>The array to be estimated</p>\n</dd>\n<dt>disable_background_masking<span class=\"classifier\">bool, default False</span></dt><dd><p>If True, uses all voxels for the estimation, otherwise, only non-zeros\nvoxels are used. Useful if the background is masked by the scanner.</p>\n</dd>\n<dt>N<span class=\"classifier\">int, default 0</span></dt><dd><p>Number of coils of the receiver array. Use N = 1 in case of a SENSE\nreconstruction (Philips scanners) or the number of coils for a GRAPPA\nreconstruction (Siemens and GE). Use 0 to disable the correction factor,\nas for example if the noise is Gaussian distributed. See [1] for more\ninformation.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id43\">\n<h4>Returns<a class=\"headerlink\" href=\"#id43\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>sigma<span class=\"classifier\">ndarray</span></dt><dd><p>standard deviation of the noise, one estimation per volume.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id44\">\n<h4>Notes<a class=\"headerlink\" href=\"#id44\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<p>This function is the same as manually taking the standard deviation of the\nbackground and gives one value for the whole 3D array.\nIt also includes the coil-dependent correction factor of Koay 2006\n(see <a href=\"#id70\"><span class=\"problematic\" id=\"id45\">[1]_</span></a>, equation 18) with theta = 0.\nSince this function was introduced in <a href=\"#id71\"><span class=\"problematic\" id=\"id46\">[2]_</span></a> for T1 imaging,\nit is expected to perform ok on diffusion MRI data, but might oversmooth\nsome regions and leave others un-denoised for spatially varying noise\nprofiles. Consider using <a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.piesno\" title=\"dipy.denoise.noise_estimate.piesno\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">piesno()</span></code></a> to estimate sigma instead if visual\ninaccuracies are apparent in the denoised result.</p>\n</section>\n<section id=\"id47\">\n<h4>References<a class=\"headerlink\" href=\"#id47\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<aside class=\"footnote-list brackets\">\n<aside class=\"footnote brackets\" id=\"id48\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>1<span class=\"fn-bracket\">]</span></span>\n<p>Koay, C. G., &amp; Basser, P. J. (2006). Analytically exact correction</p>\n</aside>\n</aside>\n<p>scheme for signal extraction from noisy magnitude MR signals.\nJournal of Magnetic Resonance), 179(2), 317-22.</p>\n<aside class=\"footnote-list brackets\">\n<aside class=\"footnote brackets\" id=\"id49\" role=\"note\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>2<span class=\"fn-bracket\">]</span></span>\n<p>Coupe, P., Yger, P., Prima, S., Hellier, P., Kervrann, C., Barillot,</p>\n</aside>\n</aside>\n<p>C., 2008. An optimized blockwise nonlocal means denoising filter for 3-D\nmagnetic resonance images, IEEE Trans. Med. Imaging 27, 425-41.</p>\n</section>\n</dd></dl>\n\n</section>\n<section id=\"non-local-means\">\n<h3>non_local_means<a class=\"headerlink\" href=\"#non-local-means\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"dipy.denoise.non_local_means.non_local_means\">\n<span class=\"sig-prename descclassname\"><span class=\"pre\">dipy.denoise.non_local_means.</span></span><span class=\"sig-name descname\"><span class=\"pre\">non_local_means</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">arr</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">sigma</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">mask</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">patch_radius</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">1</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">block_radius</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">5</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">rician</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">True</span></span></em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.non_local_means.non_local_means\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Non-local means for denoising 3D and 4D images, using</dt><dd><p>blockwise averaging approach</p>\n</dd>\n</dl>\n<section id=\"id50\">\n<h4>Parameters<a class=\"headerlink\" href=\"#id50\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>arr<span class=\"classifier\">3D or 4D ndarray</span></dt><dd><p>The array to be denoised</p>\n</dd>\n</dl>\n<p>mask : 3D ndarray\nsigma : float</p>\n<blockquote>\n<div><p>standard deviation of the noise estimated from the data</p>\n</div></blockquote>\n<dl class=\"simple\">\n<dt>patch_radius<span class=\"classifier\">int</span></dt><dd><p>patch size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">patch_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 1.</p>\n</dd>\n<dt>block_radius<span class=\"classifier\">int</span></dt><dd><p>block size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">block_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 5.</p>\n</dd>\n<dt>rician<span class=\"classifier\">boolean</span></dt><dd><p>If True the noise is estimated as Rician, otherwise Gaussian noise\nis assumed.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id51\">\n<h4>Returns<a class=\"headerlink\" href=\"#id51\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>denoised_arr<span class=\"classifier\">ndarray</span></dt><dd><p>the denoised <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code> which has the same shape as <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code>.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id52\">\n<h4>References<a class=\"headerlink\" href=\"#id52\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<div role=\"list\" class=\"citation-list\">\n<div class=\"citation\" id=\"coupe08\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>Coupe08<span class=\"fn-bracket\">]</span></span>\n<p>P. Coupe, P. Yger, S. Prima, P. Hellier, C. Kervrann, C.\nBarillot, An Optimized Blockwise Non Local Means Denoising\nFilter for 3D Magnetic Resonance Images, IEEE Transactions on\nMedical Imaging, 27(4):425-441, 2008</p>\n</div>\n<div class=\"citation\" id=\"id53\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>Coupe11<span class=\"fn-bracket\">]</span></span>\n<p>Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.\nAdaptive Multiresolution Non-Local Means Filter for 3D MR Image\nDenoising IET Image Processing, Institution of Engineering and\nTechnology, 2011</p>\n</div>\n</div>\n</section>\n</dd></dl>\n\n</section>\n<section id=\"patch2self\">\n<h3>patch2self<a class=\"headerlink\" href=\"#patch2self\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<dl class=\"py function\">\n<dt class=\"sig sig-object py\" id=\"dipy.denoise.patch2self.patch2self\">\n<span class=\"sig-prename descclassname\"><span class=\"pre\">dipy.denoise.patch2self.</span></span><span class=\"sig-name descname\"><span class=\"pre\">patch2self</span></span><span class=\"sig-paren\">(</span><em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">data</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">bvals</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">patch_radius</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">(0,</span> <span class=\"pre\">0,</span> <span class=\"pre\">0)</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">model</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">'ols'</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">b0_threshold</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">50</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">out_dtype</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">None</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">alpha</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">1.0</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">verbose</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">b0_denoising</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">True</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">clip_negative_vals</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">False</span></span></em>, <em class=\"sig-param\"><span class=\"n\"><span class=\"pre\">shift_intensity</span></span><span class=\"o\"><span class=\"pre\">=</span></span><span class=\"default_value\"><span class=\"pre\">True</span></span></em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.patch2self.patch2self\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Patch2Self Denoiser.</p>\n<section id=\"id54\">\n<h4>Parameters<a class=\"headerlink\" href=\"#id54\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>data<span class=\"classifier\">ndarray</span></dt><dd><p>The 4D noisy DWI data to be denoised.</p>\n</dd>\n<dt>bvals<span class=\"classifier\">1D array</span></dt><dd><p>Array of the bvals from the DWI acquisition</p>\n</dd>\n<dt>patch_radius<span class=\"classifier\">int or 1D array, optional</span></dt><dd><p>The radius of the local patch to be taken around each voxel (in\nvoxels). Default: 0 (denoise in blocks of 1x1x1 voxels).</p>\n</dd>\n<dt>model<span class=\"classifier\">string, or initialized linear model object.</span></dt><dd><p>This will determine the algorithm used to solve the set of linear\nequations underlying this model. If it is a string it needs to be\none of the following: {\u2018ols\u2019, \u2018ridge\u2019, \u2018lasso\u2019}. Otherwise,\nit can be an object that inherits from\n<cite>dipy.optimize.SKLearnLinearSolver</cite> or an object with a similar\ninterface from Scikit-Learn:\n<cite>sklearn.linear_model.LinearRegression</cite>,\n<cite>sklearn.linear_model.Lasso</cite> or <cite>sklearn.linear_model.Ridge</cite>\nand other objects that inherit from <cite>sklearn.base.RegressorMixin</cite>.\nDefault: \u2018ols\u2019.</p>\n</dd>\n<dt>b0_threshold<span class=\"classifier\">int, optional</span></dt><dd><p>Threshold for considering volumes as b0.</p>\n</dd>\n<dt>out_dtype<span class=\"classifier\">str or dtype, optional</span></dt><dd><p>The dtype for the output array. Default: output has the same dtype as\nthe input.</p>\n</dd>\n<dt>alpha<span class=\"classifier\">float, optional</span></dt><dd><p>Regularization parameter only for ridge regression model.</p>\n</dd>\n<dt>verbose<span class=\"classifier\">bool, optional</span></dt><dd><p>Show progress of Patch2Self and time taken.</p>\n</dd>\n<dt>b0_denoising<span class=\"classifier\">bool, optional</span></dt><dd><p>Skips denoising b0 volumes if set to False.</p>\n</dd>\n<dt>clip_negative_vals<span class=\"classifier\">bool, optional</span></dt><dd><p>Sets negative values after denoising to 0 using <cite>np.clip</cite>.</p>\n</dd>\n<dt>shift_intensity<span class=\"classifier\">bool, optional</span></dt><dd><p>Shifts the distribution of intensities per volume to give\nnon-negative values</p>\n</dd>\n</dl>\n</section>\n<section id=\"id55\">\n<h4>Returns<a class=\"headerlink\" href=\"#id55\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>denoised array<span class=\"classifier\">ndarray</span></dt><dd><p>This is the denoised array of the same size as that of the input data,\nclipped to non-negative values.</p>\n</dd>\n</dl>\n</section>\n<section id=\"id56\">\n<h4>References<a class=\"headerlink\" href=\"#id56\" title=\"Permalink to this heading\">\u00b6</a></h4>\n<dl class=\"simple\">\n<dt>[Fadnavis20] S. Fadnavis, J. Batson, E. Garyfallidis, Patch2Self:</dt><dd><p>Denoising Diffusion MRI with Self-supervised Learning,\nAdvances in Neural Information Processing Systems 33 (2020)</p>\n</dd>\n</dl>\n</section>\n</dd></dl>\n\n</section>\n</section>\n</section>\n", "metatags": "<meta name=\"generator\" content=\"Docutils 0.19: https://docutils.sourceforge.io/\" />\n", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["reference/dipy.direction", "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">direction</span></code>", "N", "next"], ["reference/dipy.data", "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">data</span></code>", "P", "previous"]], "sourcename": "reference/dipy.denoise.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.adaptive_soft_matching\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.adaptive_soft_matching</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.gibbs\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.gibbs</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.localpca\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.localpca</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.nlmeans\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.nlmeans</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.noise_estimate\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.noise_estimate</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.non_local_means\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.non_local_means</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.patch2self\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.patch2self</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#adaptive-soft-matching\">adaptive_soft_matching</a><ul>\n<li><a class=\"reference internal\" href=\"#dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\"><code class=\"docutils literal notranslate\"><span class=\"pre\">adaptive_soft_matching()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#gibbs-removal\">gibbs_removal</a><ul>\n<li><a class=\"reference internal\" href=\"#dipy.denoise.gibbs.gibbs_removal\"><code class=\"docutils literal notranslate\"><span class=\"pre\">gibbs_removal()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#genpca\">genpca</a><ul>\n<li><a class=\"reference internal\" href=\"#dipy.denoise.localpca.genpca\"><code class=\"docutils literal notranslate\"><span class=\"pre\">genpca()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#localpca\">localpca</a><ul>\n<li><a class=\"reference internal\" href=\"#dipy.denoise.localpca.localpca\"><code class=\"docutils literal notranslate\"><span class=\"pre\">localpca()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#mppca\">mppca</a><ul>\n<li><a class=\"reference internal\" href=\"#dipy.denoise.localpca.mppca\"><code class=\"docutils literal notranslate\"><span class=\"pre\">mppca()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#nlmeans\">nlmeans</a><ul>\n<li><a class=\"reference internal\" href=\"#dipy.denoise.nlmeans.nlmeans\"><code class=\"docutils literal notranslate\"><span class=\"pre\">nlmeans()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#piesno\">piesno</a><ul>\n<li><a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.piesno\"><code class=\"docutils literal notranslate\"><span class=\"pre\">piesno()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#estimate-sigma\">estimate_sigma</a><ul>\n<li><a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.estimate_sigma\"><code class=\"docutils literal notranslate\"><span class=\"pre\">estimate_sigma()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#non-local-means\">non_local_means</a><ul>\n<li><a class=\"reference internal\" href=\"#dipy.denoise.non_local_means.non_local_means\"><code class=\"docutils literal notranslate\"><span class=\"pre\">non_local_means()</span></code></a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#patch2self\">patch2self</a><ul>\n<li><a class=\"reference internal\" href=\"#dipy.denoise.patch2self.patch2self\"><code class=\"docutils literal notranslate\"><span class=\"pre\">patch2self()</span></code></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "reference/dipy.denoise", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}
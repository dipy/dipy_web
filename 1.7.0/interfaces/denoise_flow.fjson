{"parents": [{"link": "../../documentation/", "title": "Documentation"}, {"link": "../", "title": "DIPY Workflows Interfaces"}], "prev": {"link": "../data_fetch/", "title": "Downloading DIPY datasets"}, "next": {"link": "../motion_flow/", "title": "Between-Volumes Motion Correction"}, "title": "Denoising", "meta": {}, "body": "<section id=\"denoising\">\n<span id=\"denoise-flow\"></span><h1>Denoising<a class=\"headerlink\" href=\"#denoising\" title=\"Permalink to this heading\">\u00b6</a></h1>\n<p>This tutorial walks through the steps to denoise diffusion-weighted MR images using DIPY.\nMultiple denoising methods are available in DIPY.</p>\n<p>You can try these methods using your own data; we will be using the data in DIPY.\nYou can check how to <a class=\"reference internal\" href=\"../data_fetch/#data-fetch\"><span class=\"std std-ref\">fetch the DIPY data</span></a>.</p>\n<section id=\"denoising-using-overcomplete-local-pca\">\n<h2>Denoising using Overcomplete Local PCA<a class=\"headerlink\" href=\"#denoising-using-overcomplete-local-pca\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p>Denoising algorithms based on principal components analysis (PCA) are effective\ndenoising methods because they explore the redundancy of the multi-dimensional\ninformation of diffusion-weighted datasets. The basic idea behind the PCA-based\ndenoising algorithms is to perform a low-rank approximation by thresholding the\neigenspectrum of the noisy signal matrix.</p>\n<p>The algorithm to perform an Overcomplete Local PCA-based (LPCA) denoising\ninvolves the following steps:</p>\n<ul class=\"simple\">\n<li><p>Estimating the local noise variance at each voxel.</p></li>\n<li><p>Applying a PCA in local patches around each voxel over the gradient\ndirections.</p></li>\n<li><p>Thresholding the eigenvalues based on the local estimate of the noise\nvariance, and then doing a PCA reconstruction.</p></li>\n</ul>\n<p>The Overcomplete Local PCA algorithm turns out to work well on diffusion MRI\nowing to the 4D structure of DWI acquisitions where the q-space is typically\noversampled giving highly correlated 3D volumes of the same subject.</p>\n<p>For illustrative purposes of the Overcomplete Local PCA denoising method, we\nwill be using the <code class=\"docutils literal notranslate\"><span class=\"pre\">stanford_hardi</span></code> dataset, but you can also use your own\ndata.</p>\n<p>The workflow for the LPCA denoising requires the paths to the diffusion input\nfile, as well as the b-values and b-vectors files.</p>\n<p>You may want to create an output directory to save the denoised data, e.g.:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">mkdir</span> <span class=\"n\">denoise_lpca_output</span>\n</pre></div>\n</div>\n<p>To run the Overcomplete Local PCA denoising on the data it suffices to execute\nthe <code class=\"docutils literal notranslate\"><span class=\"pre\">dipy_denoise_lpca</span></code> command, e.g.:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">dipy_denoise_lpca</span> <span class=\"n\">data</span><span class=\"o\">/</span><span class=\"n\">stanford_hardi</span><span class=\"o\">/</span><span class=\"n\">HARDI150</span><span class=\"o\">.</span><span class=\"n\">nii</span><span class=\"o\">.</span><span class=\"n\">gz</span> <span class=\"n\">data</span><span class=\"o\">/</span><span class=\"n\">stanford_hardi</span><span class=\"o\">/</span><span class=\"n\">HARDI150</span><span class=\"o\">.</span><span class=\"n\">bval</span> <span class=\"n\">data</span><span class=\"o\">/</span><span class=\"n\">stanford_hardi</span><span class=\"o\">/</span><span class=\"n\">HARDI150</span><span class=\"o\">.</span><span class=\"n\">bvec</span> <span class=\"o\">--</span><span class=\"n\">out_dir</span> <span class=\"s2\">&quot;denoise_lpca_output&quot;</span>\n</pre></div>\n</div>\n<p>This command will denoise the diffusion image and save it to the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">denoise_lpca_output</span></code> directory, defaulting the resulting image file name to\n<code class=\"docutils literal notranslate\"><span class=\"pre\">dwi_lpca.nii.gz</span></code>. In case the output directory (<code class=\"docutils literal notranslate\"><span class=\"pre\">out_dir</span></code>) parameter is not\nspecified, the denoised diffusion image will be saved to the current directory\nby default.</p>\n<p>Note: Depending on the parameters\u2019 values, the effect of the denoising can\nbe subtle or even hardly noticeable, apparent or visible, depending on the\nchoice. Users are encouraged to carefully choose the parameters.</p>\n<table class=\"docutils align-default\">\n<thead>\n<tr class=\"row-odd\"><th class=\"head\"><p>Before Denoising</p></th>\n<th class=\"head\"><p>After Denoising</p></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_original.png?raw=true\"><img alt=\"image1\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_original.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_denoise_LPCA.png?raw=true\"><img alt=\"image2\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_denoise_LPCA.png?raw=true\" /></a></p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"denoising-using-marcenko-pastur-pca\">\n<h2>Denoising using Marcenko-Pastur PCA<a class=\"headerlink\" href=\"#denoising-using-marcenko-pastur-pca\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p>The principal components classification can be performed based on prior noise\nvariance estimates or automatically based on the Marcenko-Pastur distribution.\nIn addition to noise suppression, the Marcenko-Pastur PCA (MPPCA) algorithm can\nbe used to get the standard deviation of the noise.</p>\n<p>We will use the <code class=\"docutils literal notranslate\"><span class=\"pre\">sherbrooke_3shell</span></code> dataset in DIPY to showcase this denoising\nmethod. As with any other workflow in DIPY, you can also use your own data!</p>\n<p>We will create a directory where to save the denoised image (e.g.:\n<code class=\"docutils literal notranslate\"><span class=\"pre\">denoise_mppca_output</span></code>):</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">mkdir</span> <span class=\"n\">denoise_mppca_output</span>\n</pre></div>\n</div>\n<p>In order to run the MPPCA denoising method, we need to specify the location of\nthe diffusion data file, followed by the optional arguments. In this case, we\nwill be specifying the patch radius value and the output directory.</p>\n<p>The MPPCA denoising method is run using the <code class=\"docutils literal notranslate\"><span class=\"pre\">dipy_denoise_mppca</span></code> command,\ne.g.:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">dipy_denoise_mppca</span> <span class=\"n\">data</span><span class=\"o\">/</span><span class=\"n\">sherbrooke_3shell</span><span class=\"o\">/</span><span class=\"n\">HARDI193</span><span class=\"o\">.</span><span class=\"n\">nii</span><span class=\"o\">.</span><span class=\"n\">gz</span> <span class=\"o\">--</span><span class=\"n\">patch_radius</span> <span class=\"mi\">10</span> <span class=\"o\">--</span><span class=\"n\">out_dir</span> <span class=\"s2\">&quot;denoise_mppca_output&quot;</span>\n</pre></div>\n</div>\n<p>This command will denoise the diffusion image and save it to the specified\noutput directory.</p>\n<table class=\"docutils align-default\">\n<thead>\n<tr class=\"row-odd\"><th class=\"head\"><p>Before Denoising</p></th>\n<th class=\"head\"><p>After Denoising</p></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_3shell_original.png?raw=true\"><img alt=\"image3\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_3shell_original.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_3shell_denoise_MPPCA.png?raw=true\"><img alt=\"image4\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_3shell_denoise_MPPCA.png?raw=true\" /></a></p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"denoising-using-nlmeans\">\n<h2>Denoising using NLMEANS<a class=\"headerlink\" href=\"#denoising-using-nlmeans\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p>In the Non-Local Means algorithm (NLMEANS) <a class=\"reference internal\" href=\"../../examples_built/04_preprocessing/denoise_patch2self/#coupe08\" id=\"id1\"><span>[Coupe08]</span></a> and <a class=\"reference internal\" href=\"../../examples_built/04_preprocessing/denoise_nlmeans/#coupe11\" id=\"id2\"><span>[Coupe11]</span></a>, the value\nof a pixel is replaced by an average of a set of other pixel values: the\nspecific patches centered on the other pixels are contrasted to the patch\ncentered on the pixel of interest, and the average only applies to pixels with\npatches close to the current patch. This algorithm can also restore good\ntextures, which are distorted by other denoising algorithms.</p>\n<p>The Non-Local Means method can be used to denoise <span class=\"math notranslate nohighlight\">\\(N\\)</span>-D image data (i.e. 2D, 3D,\n4D, etc.), and thus enhance their SNR.</p>\n<p>We will use the <code class=\"docutils literal notranslate\"><span class=\"pre\">cfin_multib</span></code> dataset in DIPY to showcase this denoising\nmethod. As with any other workflow in DIPY, you can also use your own data!</p>\n<p>In order to run the NLMEANS denoising method, we need to specify the location of the\ndiffusion data file, followed by the optional arguments. In this case, we will be\nspecifying the noise standard deviation estimate (<code class=\"docutils literal notranslate\"><span class=\"pre\">sigma</span></code>) and patch radius\nvalues, and the output directory.</p>\n<p>We will create a directory where to save the denoised image (e.g.:\n<code class=\"docutils literal notranslate\"><span class=\"pre\">denoise_nlmeans_output</span></code>):</p>\n<p>The NLMEANS denoising is performed using the <code class=\"docutils literal notranslate\"><span class=\"pre\">dipy_denoise_nlmeans</span></code> command,\ne.g.:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">dipy_denoise_nlmeans</span> <span class=\"n\">data</span><span class=\"o\">/</span><span class=\"n\">cfin_multib</span><span class=\"o\">/</span><span class=\"n\">__DTI_AX_ep2d_2_5_iso_33d_20141015095334_4</span><span class=\"o\">.</span><span class=\"n\">nii</span> <span class=\"o\">--</span><span class=\"n\">sigma</span> <span class=\"mi\">2</span> <span class=\"o\">--</span><span class=\"n\">patch_radius</span> <span class=\"mi\">2</span> <span class=\"o\">--</span><span class=\"n\">out_dir</span> <span class=\"s2\">&quot;denoise_nlmeans_output&quot;</span>\n</pre></div>\n</div>\n<p>The command will denoise the input diffusion volume and write the result to the\nspecified output directory.</p>\n<table class=\"docutils align-default\">\n<thead>\n<tr class=\"row-odd\"><th class=\"head\"><p>Before Denoising</p></th>\n<th class=\"head\"><p>After Denoising</p></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_original.png?raw=true\"><img alt=\"image5\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_original.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_denoise_NLMEANS.png?raw=true\"><img alt=\"image6\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_denoise_NLMEANS.png?raw=true\" /></a></p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"overview-of-denoising-methods\">\n<h2>Overview of Denoising Methods<a class=\"headerlink\" href=\"#overview-of-denoising-methods\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p>Note: Users are recommended to zoom (click on each image) to see the denoising effect.</p>\n<section id=\"diffusion\">\n<h3>Diffusion<a class=\"headerlink\" href=\"#diffusion\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<table class=\"docutils align-default\">\n<thead>\n<tr class=\"row-odd\"><th class=\"head\"><p>Dataset</p></th>\n<th class=\"head\"><p>Original Image</p></th>\n<th class=\"head\"><p>Denoise LCPA</p></th>\n<th class=\"head\"><p>Denoise MPPCA</p></th>\n<th class=\"head\"><p>Denoise NLMEANS</p></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"row-even\"><td><p>sherbrooke_3shell</p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_3shell_original.png?raw=true\"><img alt=\"image7\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_3shell_original.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_denoise_LPCA.png?raw=true\"><img alt=\"image8\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_denoise_LPCA.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_3shell_denoise_MPPCA.png?raw=true\"><img alt=\"image9\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_3shell_denoise_MPPCA.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_denoise_NLMEANS.png?raw=true\"><img alt=\"image10\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/sherbrooke_denoise_NLMEANS.png?raw=true\" /></a></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p>stanford_hardi</p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_original.png?raw=true\"><img alt=\"image11\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_original.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_denoise_LPCA.png?raw=true\"><img alt=\"image12\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_denoise_LPCA.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_denoise_MPPCA.png?raw=true\"><img alt=\"image13\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_denoise_MPPCA.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_denoise_NLMEANS.png?raw=true\"><img alt=\"image14\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_denoise_NLMEANS.png?raw=true\" /></a></p></td>\n</tr>\n<tr class=\"row-even\"><td><p>cfin_multib</p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_original.png?raw=true\"><img alt=\"image15\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_original.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_LPCA.png?raw=true\"><img alt=\"image16\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_LPCA.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_denoise_MPPCA.png?raw=true\"><img alt=\"image17\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_denoise_MPPCA.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_denoise_NLMEANS.png?raw=true\"><img alt=\"image18\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/cfin_multib_denoise_NLMEANS.png?raw=true\" /></a></p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"structural\">\n<h3>Structural<a class=\"headerlink\" href=\"#structural\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<table class=\"docutils align-default\">\n<thead>\n<tr class=\"row-odd\"><th class=\"head\"><p>Dataset</p></th>\n<th class=\"head\"><p>Original Image</p></th>\n<th class=\"head\"><p>Denoise NLMEANS</p></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"row-even\"><td><p>stanford_hardi T1</p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_t1_original.png?raw=true\"><img alt=\"image19\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_t1_original.png?raw=true\" /></a></p></td>\n<td><p><a class=\"reference internal\" href=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_t1_NLMEANS.png?raw=true\"><img alt=\"image20\" class=\"align-middle\" src=\"https://github.com/dipy/dipy_data/blob/master/stanford_hardi_t1_NLMEANS.png?raw=true\" /></a></p></td>\n</tr>\n</tbody>\n</table>\n</section>\n<section id=\"references\">\n<h3>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<div role=\"list\" class=\"citation-list\">\n<div class=\"citation\" id=\"coupe08\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id1\">Coupe08</a><span class=\"fn-bracket\">]</span></span>\n<p>P. Coupe, P. Yger, S. Prima, P. Hellier, C. Kervrann, C. Barillot,\n\u201cAn Optimized Blockwise Non Local Means Denoising Filter for 3D Magnetic\nResonance Images\u201d, IEEE Transactions on Medical Imaging, 27(4):425-441, 2008</p>\n</div>\n<div class=\"citation\" id=\"coupe11\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id2\">Coupe11</a><span class=\"fn-bracket\">]</span></span>\n<p>Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.\n\u201cAdaptive Multiresolution Non-Local Means Filter for 3D MR Image Denoising\u201d\nIET Image Processing, Institution of Engineering and Technology, 2011</p>\n</div>\n</div>\n</section>\n</section>\n</section>\n", "metatags": "<meta name=\"generator\" content=\"Docutils 0.19: https://docutils.sourceforge.io/\" />\n", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["interfaces/motion_flow", "Between-Volumes Motion Correction", "N", "next"], ["interfaces/data_fetch", "Downloading DIPY datasets", "P", "previous"]], "sourcename": "interfaces/denoise_flow.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Denoising</a><ul>\n<li><a class=\"reference internal\" href=\"#denoising-using-overcomplete-local-pca\">Denoising using Overcomplete Local PCA</a></li>\n<li><a class=\"reference internal\" href=\"#denoising-using-marcenko-pastur-pca\">Denoising using Marcenko-Pastur PCA</a></li>\n<li><a class=\"reference internal\" href=\"#denoising-using-nlmeans\">Denoising using NLMEANS</a></li>\n<li><a class=\"reference internal\" href=\"#overview-of-denoising-methods\">Overview of Denoising Methods</a><ul>\n<li><a class=\"reference internal\" href=\"#diffusion\">Diffusion</a></li>\n<li><a class=\"reference internal\" href=\"#structural\">Structural</a></li>\n<li><a class=\"reference internal\" href=\"#references\">References</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "interfaces/denoise_flow", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}
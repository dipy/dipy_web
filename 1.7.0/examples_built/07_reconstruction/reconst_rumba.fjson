{"parents": [{"link": "../../../documentation/", "title": "Documentation"}, {"link": "../../", "title": "Examples"}, {"link": "../", "title": "Reconstruction"}], "prev": {"link": "../reconst_msdki/", "title": "Mean signal diffusion kurtosis imaging (MSDKI)"}, "next": {"link": "../reconst_qtdmri/", "title": "Estimating diffusion time dependent q-space indices using qt-dMRI"}, "title": "Reconstruction with Robust and Unbiased Model-BAsed Spherical Deconvolution", "meta": null, "body": "<div class=\"sphx-glr-download-link-note admonition note\">\n<p class=\"admonition-title\">Note</p>\n<p>Click <a class=\"reference internal\" href=\"#sphx-glr-download-examples-built-07-reconstruction-reconst-rumba-py\"><span class=\"std std-ref\">here</span></a>\nto download the full example code</p>\n</div>\n<section class=\"sphx-glr-example-title\" id=\"reconstruction-with-robust-and-unbiased-model-based-spherical-deconvolution\">\n<span id=\"sphx-glr-examples-built-07-reconstruction-reconst-rumba-py\"></span><h1>Reconstruction with Robust and Unbiased Model-BAsed Spherical Deconvolution<a class=\"headerlink\" href=\"#reconstruction-with-robust-and-unbiased-model-based-spherical-deconvolution\" title=\"Permalink to this heading\">\u00b6</a></h1>\n<p>This example shows how to use RUMBA-SD to reconstruct fiber orientation\ndensity functions (fODFs). This model was introduced by Canales-Rodriguez\net al <a class=\"reference internal\" href=\"../../13_fiber_tracking/tracking_rumba/#canalesrodriguez2015\" id=\"id1\"><span>[CanalesRodriguez2015]</span></a>.</p>\n<p>RUMBA-SD uses a priori information about the fiber response function (axial\nand perpendicular diffusivities) to generate a convolution kernel mapping the\nfODFs on a sphere to the recorded data. The fODFs are then estimated using an\niterative, maximum likelihood estimation algorithm adapted from Richardson-Lucy\n(RL) deconvolution <a class=\"reference internal\" href=\"#richardson1972\" id=\"id2\"><span>[Richardson1972]</span></a>. Specifically, the RL algorithm assumes\nGaussian noise, while RUMBA assumes Rician/Noncentral Chi noise \u2013 these more\naccurately reflect the noise generated by MRI scanners <a class=\"reference internal\" href=\"#constantinides1997\" id=\"id3\"><span>[Constantinides1997]</span></a>.\nThis algorithm also contains an optional compartment for estimating an\nisotropic volume fraction to account for partial volume effects. RUMBA-SD works\nwith single- and multi-shell data, as well as data recorded in Cartesian or\nspherical coordinate systems.</p>\n<p>The result from RUMBA-SD can be smoothed by applying total variation spatial\nregularization (termed RUMBA-SD + TV), a technique which promotes a more\ncoherent estimate of the fODFs across neighboring voxels <a class=\"reference internal\" href=\"#rudin1992\" id=\"id4\"><span>[Rudin1992]</span></a>.\nThis regularization ability is also included in this implementation.</p>\n<dl class=\"simple\">\n<dt>This example will showcase how to:</dt><dd><ol class=\"arabic simple\">\n<li><p>Estimate the fiber response function</p></li>\n<li><p>Reconstruct the fODFs voxel-wise or globally with TV regularization</p></li>\n<li><p>Visualize fODF maps</p></li>\n</ol>\n</dd>\n</dl>\n<p>To begin, we will load the data, consisting of 10 b0s and 150 non-b0s with a\nb-value of 2000.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.core.gradients</span> <span class=\"kn\">import</span> <span class=\"n\">gradient_table</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"kn\">import</span> <span class=\"n\">get_fnames</span><span class=\"p\">,</span> <span class=\"n\">get_sphere</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.io.gradients</span> <span class=\"kn\">import</span> <span class=\"n\">read_bvals_bvecs</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.io.image</span> <span class=\"kn\">import</span> <span class=\"n\">load_nifti</span>\n\n<span class=\"n\">hardi_fname</span><span class=\"p\">,</span> <span class=\"n\">hardi_bval_fname</span><span class=\"p\">,</span> <span class=\"n\">hardi_bvec_fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;stanford_hardi&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">affine</span> <span class=\"o\">=</span> <span class=\"n\">load_nifti</span><span class=\"p\">(</span><span class=\"n\">hardi_fname</span><span class=\"p\">)</span>\n\n<span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span> <span class=\"o\">=</span> <span class=\"n\">read_bvals_bvecs</span><span class=\"p\">(</span><span class=\"n\">hardi_bval_fname</span><span class=\"p\">,</span> <span class=\"n\">hardi_bvec_fname</span><span class=\"p\">)</span>\n<span class=\"n\">gtab</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table</span><span class=\"p\">(</span><span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span><span class=\"p\">)</span>\n\n<span class=\"n\">sphere</span> <span class=\"o\">=</span> <span class=\"n\">get_sphere</span><span class=\"p\">(</span><span class=\"s1\">&#39;symmetric362&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<section id=\"step-1-estimation-of-the-fiber-response-function\">\n<h2>Step 1. Estimation of the fiber response function<a class=\"headerlink\" href=\"#step-1-estimation-of-the-fiber-response-function\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p>There are multiple ways to estimate the fiber response function.</p>\n<p><strong>Strategy 1: use default values</strong>\nOne simple approach is to use the values included as the default arguments in\nthe RumbaSDModel constructor. The white matter response, <cite>wm_response</cite> has three\nvalues corresponding to the tensor eigenvalues (1.7e-3, 0.2e-3, 0.2e-3). The\nmodel has compartments for cerebrospinal fluid (CSF) (<cite>csf_response</cite>) and\ngrey matter (GM) (<cite>gm_response</cite>) as well, with these mean diffusivities set\nto 3.0e-3 and 0.8e-3 respectively <a class=\"reference internal\" href=\"../../13_fiber_tracking/tracking_rumba/#canalesrodriguez2015\" id=\"id5\"><span>[CanalesRodriguez2015]</span></a>. These default\nvalues will often be adequate as RUMBA-SD is robust against impulse response\nimprecision [Dell\u2019Acqua2007]_.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.rumba</span> <span class=\"kn\">import</span> <span class=\"n\">RumbaSDModel</span>\n\n<span class=\"n\">rumba</span> <span class=\"o\">=</span> <span class=\"n\">RumbaSDModel</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;wm_response: </span><span class=\"si\">{</span><span class=\"n\">rumba</span><span class=\"o\">.</span><span class=\"n\">wm_response</span><span class=\"si\">}</span><span class=\"s2\">, &quot;</span> <span class=\"o\">+</span>\n      <span class=\"sa\">f</span><span class=\"s2\">&quot;csf_response: </span><span class=\"si\">{</span><span class=\"n\">rumba</span><span class=\"o\">.</span><span class=\"n\">csf_response</span><span class=\"si\">}</span><span class=\"s2\">, &quot;</span> <span class=\"o\">+</span>\n      <span class=\"sa\">f</span><span class=\"s2\">&quot;gm_response: </span><span class=\"si\">{</span><span class=\"n\">rumba</span><span class=\"o\">.</span><span class=\"n\">gm_response</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>wm_response: [0.0017 0.0002 0.0002], csf_response: 0.003, gm_response: 0.0008\n</pre></div>\n</div>\n<p>wm_response: [0.0017 0.0002 0.0002]\ncsf_response: 0.003\ngm_response: 0.0008</p>\n<p>We can visualize what this default response looks like.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.sims.voxel</span> <span class=\"kn\">import</span> <span class=\"n\">single_tensor_odf</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"kn\">import</span> <span class=\"n\">window</span><span class=\"p\">,</span> <span class=\"n\">actor</span>\n\n<span class=\"c1\"># Enables/disables interactive visualization</span>\n<span class=\"n\">interactive</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n<span class=\"n\">scene</span> <span class=\"o\">=</span> <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">Scene</span><span class=\"p\">()</span>\n\n<span class=\"n\">evals</span> <span class=\"o\">=</span> <span class=\"n\">rumba</span><span class=\"o\">.</span><span class=\"n\">wm_response</span>\n<span class=\"n\">evecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span><span class=\"o\">.</span><span class=\"n\">T</span>\n\n<span class=\"n\">response_odf</span> <span class=\"o\">=</span> <span class=\"n\">single_tensor_odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"o\">.</span><span class=\"n\">vertices</span><span class=\"p\">,</span> <span class=\"n\">evals</span><span class=\"p\">,</span> <span class=\"n\">evecs</span><span class=\"p\">)</span>\n<span class=\"c1\"># Transform our data from 1D to 4D</span>\n<span class=\"n\">response_odf</span> <span class=\"o\">=</span> <span class=\"n\">response_odf</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"p\">:]</span>\n<span class=\"n\">response_actor</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">odf_slicer</span><span class=\"p\">(</span><span class=\"n\">response_odf</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span>\n                                  <span class=\"n\">colormap</span><span class=\"o\">=</span><span class=\"s1\">&#39;plasma&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">response_actor</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as default_response.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;default_response.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">))</span>\n\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_rumba_001.png\" srcset=\"../../_images/sphx_glr_reconst_rumba_001.png\" alt=\"reconst rumba\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as default_response.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id7\">\n<img alt=\"examples_built/07_reconstruction/default_response.png\" src=\"examples_built/07_reconstruction/default_response.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Default response function.</span><a class=\"headerlink\" href=\"#id7\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">rm</span><span class=\"p\">(</span><span class=\"n\">response_actor</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p><strong>Strategy 2: estimate from local brain region</strong>\nThe <cite>csdeconv</cite> module contains functions for estimating this response.\n<cite>auto_response_sst</cite> extracts an ROI in the center of the brain and isolates\nsingle fiber populations from the corpus callosum using an FA mask with a\nthreshold of 0.7. These voxels are used to estimate the response function.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.csdeconv</span> <span class=\"kn\">import</span> <span class=\"n\">auto_response_ssst</span>\n\n<span class=\"n\">response</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">auto_response_ssst</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">roi_radii</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">fa_thr</span><span class=\"o\">=</span><span class=\"mf\">0.7</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>(array([0.00139919, 0.0003007 , 0.0003007 ]), 416.7372408293461)\n</pre></div>\n</div>\n<p>(array([0.00139919, 0.0003007 , 0.0003007]), 416.7372408293461)</p>\n<p>This response contains the estimated eigenvalues in its first element, and the\nestimated S0 in the second. The eigenvalues are all we care about for using\nRUMBA-SD.</p>\n<p>We can visualize this estimated response as well.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">evals</span> <span class=\"o\">=</span> <span class=\"n\">response</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">evecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span><span class=\"o\">.</span><span class=\"n\">T</span>\n\n<span class=\"n\">response_odf</span> <span class=\"o\">=</span> <span class=\"n\">single_tensor_odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"o\">.</span><span class=\"n\">vertices</span><span class=\"p\">,</span> <span class=\"n\">evals</span><span class=\"p\">,</span> <span class=\"n\">evecs</span><span class=\"p\">)</span>\n<span class=\"c1\"># transform our data from 1D to 4D</span>\n<span class=\"n\">response_odf</span> <span class=\"o\">=</span> <span class=\"n\">response_odf</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"p\">:]</span>\n<span class=\"n\">response_actor</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">odf_slicer</span><span class=\"p\">(</span><span class=\"n\">response_odf</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span>\n                                  <span class=\"n\">colormap</span><span class=\"o\">=</span><span class=\"s1\">&#39;plasma&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">response_actor</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as estimated_response.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;estimated_response.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_rumba_002.png\" srcset=\"../../_images/sphx_glr_reconst_rumba_002.png\" alt=\"reconst rumba\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as estimated_response.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id8\">\n<img alt=\"examples_built/07_reconstruction/estimated_response.png\" src=\"examples_built/07_reconstruction/estimated_response.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Estimated response function.</span><a class=\"headerlink\" href=\"#id8\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">rm</span><span class=\"p\">(</span><span class=\"n\">response_actor</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p><strong>Strategy 3: recursive, data-driven estimation</strong>\nThe other method for extracting a response function uses a recursive approach.\nHere, we initialize a \u201cfat\u201d response function, which is used in CSD. From this\ndeconvolution, the voxels with one peak are extracted and their data is\naveraged to get a new response function. This is repeated iteratively until\nconvergence <a class=\"reference internal\" href=\"#tax2014\" id=\"id6\"><span>[Tax2014]</span></a>.</p>\n<p>To shorten computation time, a mask can be estimated for the data.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.csdeconv</span> <span class=\"kn\">import</span> <span class=\"n\">recursive_response</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.mask</span> <span class=\"kn\">import</span> <span class=\"n\">median_otsu</span>\n\n<span class=\"n\">b0_mask</span><span class=\"p\">,</span> <span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">median_otsu</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">median_radius</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n                            <span class=\"n\">numpass</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">vol_idx</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">))</span>\n\n<span class=\"n\">rec_response</span> <span class=\"o\">=</span> <span class=\"n\">recursive_response</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"n\">mask</span><span class=\"p\">,</span> <span class=\"n\">sh_order</span><span class=\"o\">=</span><span class=\"mi\">8</span><span class=\"p\">,</span>\n                                  <span class=\"n\">peak_thr</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span> <span class=\"n\">init_fa</span><span class=\"o\">=</span><span class=\"mf\">0.08</span><span class=\"p\">,</span>\n                                  <span class=\"n\">init_trace</span><span class=\"o\">=</span><span class=\"mf\">0.0021</span><span class=\"p\">,</span> <span class=\"nb\">iter</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">convergence</span><span class=\"o\">=</span><span class=\"mf\">0.001</span><span class=\"p\">,</span>\n                                  <span class=\"n\">parallel</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">num_processes</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>/Users/skoudoro/devel/dipy/dipy/reconst/csdeconv.py:1165: RuntimeWarning: invalid value encountered in divide\n  single_peak_mask = (vals[:, 1] / vals[:, 0]) &lt; peak_thr\n</pre></div>\n</div>\n<p>We can now visualize this response, which will look like a pancake.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">rec_response_signal</span> <span class=\"o\">=</span> <span class=\"n\">rec_response</span><span class=\"o\">.</span><span class=\"n\">on_sphere</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n<span class=\"c1\"># transform our data from 1D to 4D</span>\n<span class=\"n\">rec_response_signal</span> <span class=\"o\">=</span> <span class=\"n\">rec_response_signal</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"p\">:]</span>\n<span class=\"n\">response_actor</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">odf_slicer</span><span class=\"p\">(</span><span class=\"n\">rec_response_signal</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span>\n                                  <span class=\"n\">colormap</span><span class=\"o\">=</span><span class=\"s1\">&#39;plasma&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">response_actor</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as recursive_response.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;recursive_response.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_rumba_003.png\" srcset=\"../../_images/sphx_glr_reconst_rumba_003.png\" alt=\"reconst rumba\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as recursive_response.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id9\">\n<img alt=\"examples_built/07_reconstruction/recursive_response.png\" src=\"examples_built/07_reconstruction/recursive_response.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Recursive response function.</span><a class=\"headerlink\" href=\"#id9\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">rm</span><span class=\"p\">(</span><span class=\"n\">response_actor</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</section>\n<section id=\"step-2-fodf-reconstruction\">\n<h2>Step 2. fODF Reconstruction<a class=\"headerlink\" href=\"#step-2-fodf-reconstruction\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p>We will now use the estimated response function with the RUMBA-SD model to\nreconstruct the fODFs. We will use the default value for <cite>csf_response</cite> and\n<cite>gm_response</cite>. If one doesn\u2019t wish to fit these compartments, one can specify\neither argument as <cite>None</cite>. This will result in the corresponding volume\nfraction map being all zeroes. The GM compartment can only be accurately\nestimated with at least 3-shell data. With less shells, it is recommended\nto only keep the compartment for CSF. Since this data is single-shell, we will\nonly compute the CSF compartment.</p>\n<p>RUMBA-SD can fit the data voxelwise or globally. By default, a voxelwise\napproach is used (<cite>voxelwise</cite> is set to <cite>True</cite>). However, by setting\n<cite>voxelwise</cite> to false, the whole brain can be fit at once. In this global\nsetting, one can specify the use of TV regularization with <cite>use_tv</cite>, and the\nmodel can log updates on its progress and estimated signal-to-noise ratios by\nsetting <cite>verbose</cite> to True. By default, both <cite>use_tv</cite> and <cite>verbose</cite> are set to\n<cite>False</cite> as they have no bearing on the voxelwise fit.</p>\n<p>When constructing the RUMBA-SD model, one can also specify <cite>n_iter</cite>,\n<cite>recon_type</cite>, <cite>n_coils</cite>, <cite>R</cite>, and <cite>sphere</cite>. <cite>n_iter</cite> is the number of\niterations for the iterative estimation, and the default value of 600\nshould be suitable for most applications. <cite>recon_type</cite> is the technique used\nby the MRI scanner to reconstruct the MRI signal, and should be either \u2018smf\u2019\nfor \u2018spatial matched filter\u2019, or \u2018sos\u2019 for \u2018sum-of-squares\u2019; \u2018smf\u2019 is a common\nchoice and is the default, but the specifications of the MRI scanner used to\ncollect the data should be checked. If \u2018sos\u2019 is used, then it\u2019s important to\nspecify <cite>n_coils</cite>, which is the number of coils in the MRI scanner. With \u2018smf\u2019,\nthis isn\u2019t important and the default argument of 1 can be used. <cite>R</cite> is the\nacceleration factor of the MRI scanner, which is termed the iPAT factor for\nSIEMENS, the ASSET factor for GE, or the SENSE factor for PHILIPS. 1 is a\ncommon choice, and is the default for the model. This is only important when\nusing TV regularization, which will be covered later in the tutorial. Finally,\n<cite>sphere</cite> specifies the sphere on which to construct the fODF. The default is\n\u2018repulsion724\u2019 sphere, but this tutorial will use <cite>symmetric362</cite>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">rumba</span> <span class=\"o\">=</span> <span class=\"n\">RumbaSDModel</span><span class=\"p\">(</span>\n    <span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">wm_response</span><span class=\"o\">=</span><span class=\"n\">response</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">gm_response</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>For efficiency, we will only fit a small part of the data. This is the same\nportion of data used in <span class=\"xref std std-ref\">example_reconst_csd</span>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">data_small</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"mi\">20</span><span class=\"p\">:</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"mi\">55</span><span class=\"p\">:</span><span class=\"mi\">85</span><span class=\"p\">,</span> <span class=\"mi\">38</span><span class=\"p\">:</span><span class=\"mi\">39</span><span class=\"p\">]</span>\n</pre></div>\n</div>\n<p><strong>Option 1: voxel-wise fit</strong>\nThis is the default approach for generating ODFs, wherein each voxel is fit\nsequentially.</p>\n<p>We will estimate the fODFs using the \u2018symmetric362\u2019 sphere. This\nwill take about a minute to compute.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">rumba_fit</span> <span class=\"o\">=</span> <span class=\"n\">rumba</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">data_small</span><span class=\"p\">)</span>\n<span class=\"n\">odf</span> <span class=\"o\">=</span> <span class=\"n\">rumba_fit</span><span class=\"o\">.</span><span class=\"n\">odf</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>The inclusion of RUMBA-SD\u2019s CSF compartment means we can also extract\nthe isotropic volume fraction map as well as the white matter volume fraction\nmap (the fODF sum at each voxel). These values are normalized such that they\nsum to 1. If neither isotropic compartment is included, then the isotropic\nvolume fraction map will all be zeroes.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">f_iso</span> <span class=\"o\">=</span> <span class=\"n\">rumba_fit</span><span class=\"o\">.</span><span class=\"n\">f_iso</span>\n<span class=\"n\">f_wm</span> <span class=\"o\">=</span> <span class=\"n\">rumba_fit</span><span class=\"o\">.</span><span class=\"n\">f_wm</span>\n</pre></div>\n</div>\n<p>We can visualize these maps using adjacent heatmaps.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n\n<span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">axs</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n\n<span class=\"n\">ax0</span> <span class=\"o\">=</span> <span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">f_wm</span><span class=\"p\">[</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"s1\">&#39;lower&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"s2\">&quot;Voxelwise White Matter Volume Fraction&quot;</span><span class=\"p\">)</span>\n\n<span class=\"n\">ax1</span> <span class=\"o\">=</span> <span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">f_iso</span><span class=\"p\">[</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"s1\">&#39;lower&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"s2\">&quot;Voxelwise Isotropic Volume Fraction&quot;</span><span class=\"p\">)</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">colorbar</span><span class=\"p\">(</span><span class=\"n\">ax0</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">colorbar</span><span class=\"p\">(</span><span class=\"n\">ax1</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">savefig</span><span class=\"p\">(</span><span class=\"s1\">&#39;wm_iso_partition.png&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_rumba_004.png\" srcset=\"../../_images/sphx_glr_reconst_rumba_004.png\" alt=\"reconst rumba\" class = \"sphx-glr-single-img\"/><figure class=\"align-center\" id=\"id10\">\n<img alt=\"examples_built/07_reconstruction/wm_iso_partition.png\" src=\"examples_built/07_reconstruction/wm_iso_partition.png\" />\n<figcaption>\n<p><span class=\"caption-text\">White matter and isotropic volume fractions</span><a class=\"headerlink\" href=\"#id10\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<p>To visualize the fODFs, it\u2019s recommended to combine the fODF and the isotropic\ncomponents. This is done using the <cite>RumbaFit</cite> object\u2019s method\n<cite>combined_odf_iso</cite>. To reach a proper scale for visualization, the argument\n<cite>norm=True</cite> is used in FURY\u2019s <cite>odf_slicer</cite> method.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">rumba_fit</span><span class=\"o\">.</span><span class=\"n\">combined_odf_iso</span>\n\n<span class=\"n\">fodf_spheres</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">odf_slicer</span><span class=\"p\">(</span>\n    <span class=\"n\">combined</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">norm</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">colormap</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">fodf_spheres</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as rumba_odfs.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;rumba_odfs.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_rumba_005.png\" srcset=\"../../_images/sphx_glr_reconst_rumba_005.png\" alt=\"reconst rumba\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as rumba_odfs.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id11\">\n<img alt=\"examples_built/07_reconstruction/rumba_odfs.png\" src=\"examples_built/07_reconstruction/rumba_odfs.png\" />\n<figcaption>\n<p><span class=\"caption-text\">RUMBA-SD fODFs</span><a class=\"headerlink\" href=\"#id11\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">rm</span><span class=\"p\">(</span><span class=\"n\">fodf_spheres</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We can extract the peaks from these fODFs using <cite>peaks_from_model</cite>. This will\nreconstruct the fODFs again, so will take about a minute to run.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.direction</span> <span class=\"kn\">import</span> <span class=\"n\">peaks_from_model</span>\n\n<span class=\"n\">rumba_peaks</span> <span class=\"o\">=</span> <span class=\"n\">peaks_from_model</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"o\">=</span><span class=\"n\">rumba</span><span class=\"p\">,</span>\n                               <span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">data_small</span><span class=\"p\">,</span>\n                               <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span>\n                               <span class=\"n\">relative_peak_threshold</span><span class=\"o\">=</span><span class=\"mf\">.5</span><span class=\"p\">,</span>\n                               <span class=\"n\">min_separation_angle</span><span class=\"o\">=</span><span class=\"mi\">25</span><span class=\"p\">,</span>\n                               <span class=\"n\">normalize_peaks</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span>\n                               <span class=\"n\">parallel</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                               <span class=\"n\">num_processes</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>For visualization, we scale up the peak values.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">peak_values</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">clip</span><span class=\"p\">(</span><span class=\"n\">rumba_peaks</span><span class=\"o\">.</span><span class=\"n\">peak_values</span> <span class=\"o\">*</span> <span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">peak_dirs</span> <span class=\"o\">=</span> <span class=\"n\">rumba_peaks</span><span class=\"o\">.</span><span class=\"n\">peak_dirs</span>\n\n<span class=\"n\">fodf_peaks</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">peak_slicer</span><span class=\"p\">(</span><span class=\"n\">peak_dirs</span><span class=\"p\">,</span> <span class=\"n\">peak_values</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">fodf_peaks</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as rumba_peaks.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;rumba_peaks.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_rumba_006.png\" srcset=\"../../_images/sphx_glr_reconst_rumba_006.png\" alt=\"reconst rumba\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as rumba_peaks.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id12\">\n<img alt=\"examples_built/07_reconstruction/rumba_peaks.png\" src=\"examples_built/07_reconstruction/rumba_peaks.png\" />\n<figcaption>\n<p><span class=\"caption-text\">RUMBA-SD peaks</span><a class=\"headerlink\" href=\"#id12\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">rm</span><span class=\"p\">(</span><span class=\"n\">fodf_peaks</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p><strong>Option 2: global fit</strong>\nInstead of the voxel-wise fit, RUMBA also comes with an implementation of\nglobal fitting where all voxels are fit simultaneously. This comes with some\npotential benefits such as:</p>\n<ol class=\"arabic simple\">\n<li><p>More efficient fitting due to matrix parallelization, in exchange for\nlarger demands on RAM (&gt;= 16 GB should be sufficient)</p></li>\n<li><p>The option for spatial regularization; specifically, TV regularization is\nbuilt into the fitting function (RUMBA-SD + TV)</p></li>\n</ol>\n<p>This is done by setting <cite>voxelwise</cite> to <cite>False</cite>, and setting <cite>use_tv</cite> to <cite>True</cite>.</p>\n<p>TV regularization requires a volume without any singleton dimensions, so we\u2019ll\nhave to start by expanding our data slice.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">rumba</span> <span class=\"o\">=</span> <span class=\"n\">RumbaSDModel</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">wm_response</span><span class=\"o\">=</span><span class=\"n\">response</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">gm_response</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n                     <span class=\"n\">voxelwise</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">use_tv</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n<span class=\"n\">data_tv</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"mi\">20</span><span class=\"p\">:</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"mi\">55</span><span class=\"p\">:</span><span class=\"mi\">85</span><span class=\"p\">,</span> <span class=\"mi\">38</span><span class=\"p\">:</span><span class=\"mi\">40</span><span class=\"p\">]</span>\n</pre></div>\n</div>\n<p>Now, we fit the model in the same way. This will take about 90 seconds.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">rumba_fit</span> <span class=\"o\">=</span> <span class=\"n\">rumba</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">data_tv</span><span class=\"p\">)</span>\n\n<span class=\"n\">odf</span> <span class=\"o\">=</span> <span class=\"n\">rumba_fit</span><span class=\"o\">.</span><span class=\"n\">odf</span><span class=\"p\">()</span>\n<span class=\"n\">combined</span> <span class=\"o\">=</span> <span class=\"n\">rumba_fit</span><span class=\"o\">.</span><span class=\"n\">combined_odf_iso</span>\n</pre></div>\n</div>\n<p>Now we can visualize the combined fODF map as before.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">fodf_spheres</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">odf_slicer</span><span class=\"p\">(</span><span class=\"n\">combined</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">norm</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                                <span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">colormap</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">fodf_spheres</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as rumba_global_odfs.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;rumba_global_odfs.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_rumba_007.png\" srcset=\"../../_images/sphx_glr_reconst_rumba_007.png\" alt=\"reconst rumba\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as rumba_global_odfs.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id13\">\n<img alt=\"examples_built/07_reconstruction/rumba_global_odfs.png\" src=\"examples_built/07_reconstruction/rumba_global_odfs.png\" />\n<figcaption>\n<p><span class=\"caption-text\">RUMBA-SD + TV fODFs</span><a class=\"headerlink\" href=\"#id13\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<p>This can be compared with the result without TV regularization, and one can\nobserve that the coherence between neighboring voxels is improved.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">rm</span><span class=\"p\">(</span><span class=\"n\">fodf_spheres</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>For peak detection, <cite>peaks_from_model</cite> cannot be used as it doesn\u2019t support\nglobal fitting approaches. Instead, we\u2019ll compute our peaks using a for loop.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.direction</span> <span class=\"kn\">import</span> <span class=\"n\">peak_directions</span>\n\n<span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"n\">odf</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[:</span><span class=\"mi\">3</span><span class=\"p\">]</span>\n<span class=\"n\">npeaks</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>  <span class=\"c1\"># maximum number of peaks returned for a given voxel</span>\n<span class=\"n\">peak_dirs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">shape</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">npeaks</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)))</span>\n<span class=\"n\">peak_values</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">shape</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">npeaks</span><span class=\"p\">,)))</span>\n\n<span class=\"k\">for</span> <span class=\"n\">idx</span> <span class=\"ow\">in</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ndindex</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"p\">):</span>  <span class=\"c1\"># iterate through each voxel</span>\n    <span class=\"c1\"># Get peaks of odf</span>\n    <span class=\"n\">direction</span><span class=\"p\">,</span> <span class=\"n\">pk</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">peak_directions</span><span class=\"p\">(</span><span class=\"n\">odf</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">],</span> <span class=\"n\">sphere</span><span class=\"p\">,</span>\n                                       <span class=\"n\">relative_peak_threshold</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span>\n                                       <span class=\"n\">min_separation_angle</span><span class=\"o\">=</span><span class=\"mi\">25</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Calculate peak metrics</span>\n    <span class=\"k\">if</span> <span class=\"n\">pk</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">npeaks</span><span class=\"p\">,</span> <span class=\"n\">pk</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n        <span class=\"n\">peak_dirs</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">][:</span><span class=\"n\">n</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">direction</span><span class=\"p\">[:</span><span class=\"n\">n</span><span class=\"p\">]</span>\n        <span class=\"n\">peak_values</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">][:</span><span class=\"n\">n</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">pk</span><span class=\"p\">[:</span><span class=\"n\">n</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Scale up for visualization</span>\n<span class=\"n\">peak_values</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">clip</span><span class=\"p\">(</span><span class=\"n\">peak_values</span> <span class=\"o\">*</span> <span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">fodf_peaks</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">peak_slicer</span><span class=\"p\">(</span><span class=\"n\">peak_dirs</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">:],</span>\n                               <span class=\"n\">peak_values</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">:])</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">fodf_peaks</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as rumba_global_peaks.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;rumba_global_peaks.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_rumba_008.png\" srcset=\"../../_images/sphx_glr_reconst_rumba_008.png\" alt=\"reconst rumba\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as rumba_global_peaks.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id14\">\n<img alt=\"examples_built/07_reconstruction/rumba_global_peaks.png\" src=\"examples_built/07_reconstruction/rumba_global_peaks.png\" />\n<figcaption>\n<p><span class=\"caption-text\">RUMBA-SD + TV peaks</span><a class=\"headerlink\" href=\"#id14\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">rm</span><span class=\"p\">(</span><span class=\"n\">fodf_peaks</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<section id=\"references\">\n<h3>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<div role=\"list\" class=\"citation-list\">\n<div class=\"citation\" id=\"canalesrodriguez2015\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>CanalesRodriguez2015<span class=\"fn-bracket\">]</span></span>\n<span class=\"backrefs\">(<a role=\"doc-backlink\" href=\"#id1\">1</a>,<a role=\"doc-backlink\" href=\"#id5\">2</a>)</span>\n<p>Canales-Rodr\u00edguez, E. J., Daducci, A., Sotiropoulos,\nS. N., Caruyer, E., Aja-Fern\u00e1ndez, S., Radua, J., Mendizabal, J. M. Y.,\nIturria-Medina, Y., Melie-Garc\u00eda, L., Alem\u00e1n-G\u00f3mez, Y., Thiran, J.-P.,\nSarr\u00f3, S., Pomarol-Clotet, E., &amp; Salvador, R. (2015). Spherical\nDeconvolution of Multichannel Diffusion MRI Data with Non-Gaussian Noise\nModels and Spatial Regularization. PLOS ONE, 10(10), e0138910.\n<a class=\"reference external\" href=\"https://doi.org/10.1371/journal.pone.0138910\">https://doi.org/10.1371/journal.pone.0138910</a></p>\n</div>\n<div class=\"citation\" id=\"richardson1972\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id2\">Richardson1972</a><span class=\"fn-bracket\">]</span></span>\n<p>Richardson, W. H. (1972). Bayesian-Based Iterative Method\nof Image Restoration*. JOSA, 62(1), 55\u201359.\n<a class=\"reference external\" href=\"https://doi.org/10.1364/JOSA.62.000055\">https://doi.org/10.1364/JOSA.62.000055</a></p>\n</div>\n<div class=\"citation\" id=\"constantinides1997\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id3\">Constantinides1997</a><span class=\"fn-bracket\">]</span></span>\n<p>Constantinides, C. D., Atalar, E., &amp; McVeigh, E. R.\n(1997). Signal-to-Noise Measurements in Magnitude Images from NMR Phased\nArrays. Magnetic Resonance in Medicine: Official Journal of the Society of\nMagnetic Resonance in Medicine / Society of Magnetic Resonance in Medicine,\n38(5), 852\u2013857.</p>\n</div>\n<div class=\"citation\" id=\"rudin1992\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id4\">Rudin1992</a><span class=\"fn-bracket\">]</span></span>\n<p>Rudin, L. I., Osher, S., &amp; Fatemi, E. (1992). Nonlinear total\nvariation based noise removal algorithms. Physica D: Nonlinear Phenomena,\n60(1), 259\u2013268. <a class=\"reference external\" href=\"https://doi.org/10.1016/0167-2789(92)90242-F\">https://doi.org/10.1016/0167-2789(92)90242-F</a></p>\n</div>\n<div class=\"citation\" id=\"dellacqua2007\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span>DellAcqua2007<span class=\"fn-bracket\">]</span></span>\n<p>Dell\u2019Acqua, F., Rizzo, G., Scifo, P., Clarke, R., Scotti,\nG., &amp; Fazio, F. (2007). A Model-Based Deconvolution Approach to Solve Fiber\nCrossing in Diffusion-Weighted MR Imaging. IEEE Transactions on Bio-Medical\nEngineering, 54, 462\u2013472. <a class=\"reference external\" href=\"https://doi.org/10.1109/TBME.2006.888830\">https://doi.org/10.1109/TBME.2006.888830</a></p>\n</div>\n<div class=\"citation\" id=\"tax2014\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id6\">Tax2014</a><span class=\"fn-bracket\">]</span></span>\n<p>Tax, C. M. W., Jeurissen, B., Vos, S. B., Viergever, M. A., &amp;\nLeemans, A. (2014). Recursive calibration of the fiber response\nfunction for spherical deconvolution of diffusion MRI data.\nNeuroImage, 86, 67\u201380.\n<a class=\"reference external\" href=\"https://doi.org/10.1016/j.neuroimage.2013.07.067\">https://doi.org/10.1016/j.neuroimage.2013.07.067</a></p>\n</div>\n</div>\n<p class=\"sphx-glr-timing\"><strong>Total running time of the script:</strong> ( 10 minutes  21.597 seconds)</p>\n<div class=\"sphx-glr-footer sphx-glr-footer-example docutils container\" id=\"sphx-glr-download-examples-built-07-reconstruction-reconst-rumba-py\">\n<div class=\"sphx-glr-download sphx-glr-download-python docutils container\">\n<p><a class=\"reference download internal\" download=\"\" href=\"../../../_downloads/909d4632604b5febe5df8f35dd8f5670/reconst_rumba.py\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">Download</span> <span class=\"pre\">Python</span> <span class=\"pre\">source</span> <span class=\"pre\">code:</span> <span class=\"pre\">reconst_rumba.py</span></code></a></p>\n</div>\n<div class=\"sphx-glr-download sphx-glr-download-jupyter docutils container\">\n<p><a class=\"reference download internal\" download=\"\" href=\"../../../_downloads/5d414e669eb90685635269aeb446031c/reconst_rumba.ipynb\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">Download</span> <span class=\"pre\">Jupyter</span> <span class=\"pre\">notebook:</span> <span class=\"pre\">reconst_rumba.ipynb</span></code></a></p>\n</div>\n</div>\n<p class=\"sphx-glr-signature\"><a class=\"reference external\" href=\"https://sphinx-gallery.github.io\">Gallery generated by Sphinx-Gallery</a></p>\n</section>\n</section>\n</section>\n", "metatags": "<meta name=\"generator\" content=\"Docutils 0.19: https://docutils.sourceforge.io/\" />\n", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["examples_built/07_reconstruction/reconst_qtdmri", "Estimating diffusion time dependent q-space indices using qt-dMRI", "N", "next"], ["examples_built/07_reconstruction/reconst_msdki", "Mean signal diffusion kurtosis imaging (MSDKI)", "P", "previous"]], "sourcename": "examples_built/07_reconstruction/reconst_rumba.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Reconstruction with Robust and Unbiased Model-BAsed Spherical Deconvolution</a><ul>\n<li><a class=\"reference internal\" href=\"#step-1-estimation-of-the-fiber-response-function\">Step 1. Estimation of the fiber response function</a></li>\n<li><a class=\"reference internal\" href=\"#step-2-fodf-reconstruction\">Step 2. fODF Reconstruction</a><ul>\n<li><a class=\"reference internal\" href=\"#references\">References</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "examples_built/07_reconstruction/reconst_rumba", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}
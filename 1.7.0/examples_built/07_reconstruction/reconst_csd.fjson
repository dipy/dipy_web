{"parents": [{"link": "../../../documentation/", "title": "Documentation"}, {"link": "../../", "title": "Examples"}, {"link": "../", "title": "Reconstruction"}], "prev": {"link": "../reconst_ivim/", "title": "Intravoxel incoherent motion"}, "next": {"link": "../reconst_mcsd/", "title": "Reconstruction with Multi-Shell Multi-Tissue CSD"}, "title": "Reconstruction with Constrained Spherical Deconvolution", "meta": null, "body": "<div class=\"sphx-glr-download-link-note admonition note\">\n<p class=\"admonition-title\">Note</p>\n<p>Click <a class=\"reference internal\" href=\"#sphx-glr-download-examples-built-07-reconstruction-reconst-csd-py\"><span class=\"std std-ref\">here</span></a>\nto download the full example code</p>\n</div>\n<section class=\"sphx-glr-example-title\" id=\"reconstruction-with-constrained-spherical-deconvolution\">\n<span id=\"reconst-csd\"></span><span id=\"sphx-glr-examples-built-07-reconstruction-reconst-csd-py\"></span><h1>Reconstruction with Constrained Spherical Deconvolution<a class=\"headerlink\" href=\"#reconstruction-with-constrained-spherical-deconvolution\" title=\"Permalink to this heading\">\u00b6</a></h1>\n<p>This example shows how to use Constrained Spherical Deconvolution (CSD)\nintroduced by Tournier et al. <a class=\"reference internal\" href=\"../reconst_mcsd/#tournier2007\" id=\"id1\"><span>[Tournier2007]</span></a>.</p>\n<p>This method is mainly useful with datasets with gradient directions acquired on\na spherical grid.</p>\n<p>The basic idea with this method is that if we could estimate the response\nfunction of a single fiber then we could deconvolve the measured signal and\nobtain the underlying fiber distribution.</p>\n<p>In this way, the reconstruction of the fiber orientation distribution function\n(fODF) in CSD involves two steps:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Estimation of the fiber response function</p></li>\n<li><p>Use the response function to reconstruct the fODF</p></li>\n</ol>\n</div></blockquote>\n<p>Let\u2019s first load the data. We will use a dataset with 10 b0s and 150 non-b0s\nwith b-value 2000.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.core.gradients</span> <span class=\"kn\">import</span> <span class=\"n\">gradient_table</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"kn\">import</span> <span class=\"n\">get_fnames</span><span class=\"p\">,</span> <span class=\"n\">default_sphere</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.io.gradients</span> <span class=\"kn\">import</span> <span class=\"n\">read_bvals_bvecs</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.io.image</span> <span class=\"kn\">import</span> <span class=\"n\">load_nifti</span>\n\n<span class=\"n\">hardi_fname</span><span class=\"p\">,</span> <span class=\"n\">hardi_bval_fname</span><span class=\"p\">,</span> <span class=\"n\">hardi_bvec_fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;stanford_hardi&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">affine</span> <span class=\"o\">=</span> <span class=\"n\">load_nifti</span><span class=\"p\">(</span><span class=\"n\">hardi_fname</span><span class=\"p\">)</span>\n\n<span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span> <span class=\"o\">=</span> <span class=\"n\">read_bvals_bvecs</span><span class=\"p\">(</span><span class=\"n\">hardi_bval_fname</span><span class=\"p\">,</span> <span class=\"n\">hardi_bvec_fname</span><span class=\"p\">)</span>\n<span class=\"n\">gtab</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table</span><span class=\"p\">(</span><span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>You can verify the b-values of the dataset by looking at the attribute\n<code class=\"docutils literal notranslate\"><span class=\"pre\">gtab.bvals</span></code>. Now that a dataset with multiple gradient directions is\nloaded, we can proceed with the two steps of CSD.</p>\n<section id=\"step-1-estimation-of-the-fiber-response-function\">\n<h2>Step 1. Estimation of the fiber response function<a class=\"headerlink\" href=\"#step-1-estimation-of-the-fiber-response-function\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p>There are many strategies to estimate the fiber response function. Here two\ndifferent strategies are presented.</p>\n<p><strong>Strategy 1 - response function estimates from a local brain region</strong>\nOne simple way to estimate the fiber response function is to look for regions\nof the brain where it is known that there are single coherent fiber\npopulations. For example, if we use a ROI at the center of the brain, we will\nfind single fibers from the corpus callosum. The <code class=\"docutils literal notranslate\"><span class=\"pre\">auto_response_ssst</span></code>\nfunction will calculate FA for a cuboid ROI of radii equal to <code class=\"docutils literal notranslate\"><span class=\"pre\">roi_radii</span></code> in\nthe center of the volume and return the response function estimated in that\nregion for the voxels with FA higher than 0.7.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.csdeconv</span> <span class=\"kn\">import</span> <span class=\"p\">(</span><span class=\"n\">auto_response_ssst</span><span class=\"p\">,</span>\n                                   <span class=\"n\">mask_for_response_ssst</span><span class=\"p\">,</span>\n                                   <span class=\"n\">response_from_mask_ssst</span><span class=\"p\">)</span>\n\n<span class=\"n\">response</span><span class=\"p\">,</span> <span class=\"n\">ratio</span> <span class=\"o\">=</span> <span class=\"n\">auto_response_ssst</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">roi_radii</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">fa_thr</span><span class=\"o\">=</span><span class=\"mf\">0.7</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Note that the <code class=\"docutils literal notranslate\"><span class=\"pre\">auto_response_ssst</span></code> function calls two functions that can be\nused separately. First, the function <code class=\"docutils literal notranslate\"><span class=\"pre\">mask_for_response_ssst</span></code> creates a mask\nof voxels within the cuboid ROI that meet the FA threshold constraint. This\nmask can be used to calculate the number of voxels that were kept, or to also\napply an external mask (a WM mask for example). Second, the function\n<code class=\"docutils literal notranslate\"><span class=\"pre\">response_from_mask_ssst</span></code> takes the mask and returns the response function\ncalculated within the mask. If no changes are made to the mask between the two\ncalls, the resulting responses should be identical.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">mask_for_response_ssst</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">roi_radii</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">fa_thr</span><span class=\"o\">=</span><span class=\"mf\">0.7</span><span class=\"p\">)</span>\n<span class=\"n\">nvoxels</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">mask</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">nvoxels</span><span class=\"p\">)</span>\n\n<span class=\"n\">response</span><span class=\"p\">,</span> <span class=\"n\">ratio</span> <span class=\"o\">=</span> <span class=\"n\">response_from_mask_ssst</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>1254\n</pre></div>\n</div>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">response</span></code> tuple contains two elements. The first is an array with\nthe eigenvalues of the response function and the second is the average S0 for\nthis response.</p>\n<p>It is good practice to always validate the result of auto_response_ssst. For\nthis purpose we can print the elements of <code class=\"docutils literal notranslate\"><span class=\"pre\">response</span></code> and have a look at their\nvalues.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>(array([0.00139919, 0.0003007 , 0.0003007 ]), 416.7372408293461)\n</pre></div>\n</div>\n<p>(array([ 0.0014,  0.00029,  0.00029]), 416.206)</p>\n<p>The tensor generated from the response must be prolate (two smaller eigenvalues\nshould be equal) and look anisotropic with a ratio of second to first\neigenvalue of about 0.2. Or in other words, the axial diffusivity of this\ntensor should be around 5 times larger than the radial diffusivity.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">ratio</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>0.21491283972219544\n</pre></div>\n</div>\n<p>0.21197</p>\n<p>We can double-check that we have a good response function by visualizing the\nresponse function\u2019s ODF. Here is how you would do that:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"kn\">import</span> <span class=\"n\">window</span><span class=\"p\">,</span> <span class=\"n\">actor</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.sims.voxel</span> <span class=\"kn\">import</span> <span class=\"n\">single_tensor_odf</span>\n\n<span class=\"c1\"># Enables/disables interactive visualization</span>\n<span class=\"n\">interactive</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n<span class=\"n\">scene</span> <span class=\"o\">=</span> <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">Scene</span><span class=\"p\">()</span>\n<span class=\"n\">evals</span> <span class=\"o\">=</span> <span class=\"n\">response</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">evecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span><span class=\"o\">.</span><span class=\"n\">T</span>\n\n\n<span class=\"n\">response_odf</span> <span class=\"o\">=</span> <span class=\"n\">single_tensor_odf</span><span class=\"p\">(</span><span class=\"n\">default_sphere</span><span class=\"o\">.</span><span class=\"n\">vertices</span><span class=\"p\">,</span> <span class=\"n\">evals</span><span class=\"p\">,</span> <span class=\"n\">evecs</span><span class=\"p\">)</span>\n<span class=\"c1\"># transform our data from 1D to 4D</span>\n<span class=\"n\">response_odf</span> <span class=\"o\">=</span> <span class=\"n\">response_odf</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"p\">:]</span>\n<span class=\"n\">response_actor</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">odf_slicer</span><span class=\"p\">(</span><span class=\"n\">response_odf</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">default_sphere</span><span class=\"p\">,</span>\n                                  <span class=\"n\">colormap</span><span class=\"o\">=</span><span class=\"s1\">&#39;plasma&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">response_actor</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as csd_response.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;csd_response.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_csd_001.png\" srcset=\"../../_images/sphx_glr_reconst_csd_001.png\" alt=\"reconst csd\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as csd_response.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id3\">\n<img alt=\"examples_built/07_reconstruction/csd_response.png\" src=\"examples_built/07_reconstruction/csd_response.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Estimated response function.</span><a class=\"headerlink\" href=\"#id3\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">rm</span><span class=\"p\">(</span><span class=\"n\">response_actor</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p><strong>Strategy 2 - data-driven calibration of response function</strong> Depending\non the dataset, FA threshold may not be the best way to find the best possible\nresponse function. For one, it depends on the diffusion tensor\n(FA and first eigenvector), which has lower accuracy at high\nb-values. Alternatively, the response function can be calibrated in a\ndata-driven manner <a class=\"reference internal\" href=\"../reconst_rumba/#tax2014\" id=\"id2\"><span>[Tax2014]</span></a>.</p>\n<p>First, the data is deconvolved with a \u2018fat\u2019 response function. All voxels that\nare considered to contain only one peak in this deconvolution (as determined by\nthe peak threshold which gives an upper limit of the ratio of the second peak\nto the first peak) are maintained, and from these voxels a new response\nfunction is determined. This process is repeated until convergence is\nreached. Here we calibrate the response function on a small part of the data.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.csdeconv</span> <span class=\"kn\">import</span> <span class=\"n\">recursive_response</span>\n</pre></div>\n</div>\n<p>A WM mask can shorten computation time for the whole dataset. Here it is\ncreated based on the DTI fit.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">dipy.reconst.dti</span> <span class=\"k\">as</span> <span class=\"nn\">dti</span>\n<span class=\"n\">tenmodel</span> <span class=\"o\">=</span> <span class=\"n\">dti</span><span class=\"o\">.</span><span class=\"n\">TensorModel</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">)</span>\n<span class=\"n\">tenfit</span> <span class=\"o\">=</span> <span class=\"n\">tenmodel</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"mi\">200</span><span class=\"p\">)</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.dti</span> <span class=\"kn\">import</span> <span class=\"n\">fractional_anisotropy</span>\n<span class=\"n\">FA</span> <span class=\"o\">=</span> <span class=\"n\">fractional_anisotropy</span><span class=\"p\">(</span><span class=\"n\">tenfit</span><span class=\"o\">.</span><span class=\"n\">evals</span><span class=\"p\">)</span>\n<span class=\"n\">MD</span> <span class=\"o\">=</span> <span class=\"n\">dti</span><span class=\"o\">.</span><span class=\"n\">mean_diffusivity</span><span class=\"p\">(</span><span class=\"n\">tenfit</span><span class=\"o\">.</span><span class=\"n\">evals</span><span class=\"p\">)</span>\n<span class=\"n\">wm_mask</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">logical_or</span><span class=\"p\">(</span><span class=\"n\">FA</span> <span class=\"o\">&gt;=</span> <span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">logical_and</span><span class=\"p\">(</span><span class=\"n\">FA</span> <span class=\"o\">&gt;=</span> <span class=\"mf\">0.15</span><span class=\"p\">,</span> <span class=\"n\">MD</span> <span class=\"o\">&gt;=</span> <span class=\"mf\">0.0011</span><span class=\"p\">))))</span>\n\n<span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">recursive_response</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"n\">wm_mask</span><span class=\"p\">,</span> <span class=\"n\">sh_order</span><span class=\"o\">=</span><span class=\"mi\">8</span><span class=\"p\">,</span>\n                              <span class=\"n\">peak_thr</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span> <span class=\"n\">init_fa</span><span class=\"o\">=</span><span class=\"mf\">0.08</span><span class=\"p\">,</span>\n                              <span class=\"n\">init_trace</span><span class=\"o\">=</span><span class=\"mf\">0.0021</span><span class=\"p\">,</span> <span class=\"nb\">iter</span><span class=\"o\">=</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">convergence</span><span class=\"o\">=</span><span class=\"mf\">0.001</span><span class=\"p\">,</span>\n                              <span class=\"n\">parallel</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">num_processes</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We can check the shape of the signal of the response function, which should be\nlike  a pancake:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">response_signal</span> <span class=\"o\">=</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">on_sphere</span><span class=\"p\">(</span><span class=\"n\">default_sphere</span><span class=\"p\">)</span>\n<span class=\"c1\"># transform our data from 1D to 4D</span>\n<span class=\"n\">response_signal</span> <span class=\"o\">=</span> <span class=\"n\">response_signal</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"p\">:]</span>\n<span class=\"n\">response_actor</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">odf_slicer</span><span class=\"p\">(</span><span class=\"n\">response_signal</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">default_sphere</span><span class=\"p\">,</span>\n                                  <span class=\"n\">colormap</span><span class=\"o\">=</span><span class=\"s1\">&#39;plasma&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">scene</span> <span class=\"o\">=</span> <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">Scene</span><span class=\"p\">()</span>\n\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">response_actor</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as csd_recursive_response.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;csd_recursive_response.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_csd_002.png\" srcset=\"../../_images/sphx_glr_reconst_csd_002.png\" alt=\"reconst csd\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as csd_recursive_response.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id4\">\n<img alt=\"examples_built/07_reconstruction/csd_recursive_response.png\" src=\"examples_built/07_reconstruction/csd_recursive_response.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Estimated response function using recursive calibration.</span><a class=\"headerlink\" href=\"#id4\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">rm</span><span class=\"p\">(</span><span class=\"n\">response_actor</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</section>\n<section id=\"step-2-fodf-reconstruction\">\n<h2>Step 2. fODF reconstruction<a class=\"headerlink\" href=\"#step-2-fodf-reconstruction\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p>After estimating a response function for one of the strategies shown above,\nwe are ready to start the deconvolution process. Let\u2019s import the CSD model\nand fit the datasets.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.csdeconv</span> <span class=\"kn\">import</span> <span class=\"n\">ConstrainedSphericalDeconvModel</span>\n<span class=\"n\">csd_model</span> <span class=\"o\">=</span> <span class=\"n\">ConstrainedSphericalDeconvModel</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">response</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>For illustration purposes we will fit only a small portion of the data.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">data_small</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"mi\">20</span><span class=\"p\">:</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"mi\">55</span><span class=\"p\">:</span><span class=\"mi\">85</span><span class=\"p\">,</span> <span class=\"mi\">38</span><span class=\"p\">:</span><span class=\"mi\">39</span><span class=\"p\">]</span>\n<span class=\"n\">csd_fit</span> <span class=\"o\">=</span> <span class=\"n\">csd_model</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">data_small</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>  0%|          | 0/900 [00:00&lt;?, ?it/s]\n 53%|#####2    | 473/900 [00:00&lt;00:00, 4727.20it/s]\n100%|##########| 900/900 [00:00&lt;00:00, 4703.82it/s]\n</pre></div>\n</div>\n<p>Show the CSD-based ODFs also known as FODFs (fiber ODFs).</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">csd_odf</span> <span class=\"o\">=</span> <span class=\"n\">csd_fit</span><span class=\"o\">.</span><span class=\"n\">odf</span><span class=\"p\">(</span><span class=\"n\">default_sphere</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Here we visualize only a 30x30 region.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">fodf_spheres</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">odf_slicer</span><span class=\"p\">(</span><span class=\"n\">csd_odf</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">default_sphere</span><span class=\"p\">,</span> <span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">0.9</span><span class=\"p\">,</span>\n                                <span class=\"n\">norm</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">colormap</span><span class=\"o\">=</span><span class=\"s1\">&#39;plasma&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">fodf_spheres</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as csd_odfs.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;csd_odfs.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_csd_003.png\" srcset=\"../../_images/sphx_glr_reconst_csd_003.png\" alt=\"reconst csd\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as csd_odfs.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id5\">\n<img alt=\"examples_built/07_reconstruction/csd_odfs.png\" src=\"examples_built/07_reconstruction/csd_odfs.png\" />\n<figcaption>\n<p><span class=\"caption-text\">CSD ODFs.</span><a class=\"headerlink\" href=\"#id5\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<p>In DIPY we also provide tools for finding the peak directions (maxima) of the\nODFs. For this purpose we recommend using <code class=\"docutils literal notranslate\"><span class=\"pre\">peaks_from_model</span></code>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.direction</span> <span class=\"kn\">import</span> <span class=\"n\">peaks_from_model</span>\n\n<span class=\"n\">csd_peaks</span> <span class=\"o\">=</span> <span class=\"n\">peaks_from_model</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"o\">=</span><span class=\"n\">csd_model</span><span class=\"p\">,</span>\n                             <span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">data_small</span><span class=\"p\">,</span>\n                             <span class=\"n\">sphere</span><span class=\"o\">=</span><span class=\"n\">default_sphere</span><span class=\"p\">,</span>\n                             <span class=\"n\">relative_peak_threshold</span><span class=\"o\">=</span><span class=\"mf\">.5</span><span class=\"p\">,</span>\n                             <span class=\"n\">min_separation_angle</span><span class=\"o\">=</span><span class=\"mi\">25</span><span class=\"p\">,</span>\n                             <span class=\"n\">parallel</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                             <span class=\"n\">num_processes</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">clear</span><span class=\"p\">()</span>\n<span class=\"n\">fodf_peaks</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">peak_slicer</span><span class=\"p\">(</span><span class=\"n\">csd_peaks</span><span class=\"o\">.</span><span class=\"n\">peak_dirs</span><span class=\"p\">,</span> <span class=\"n\">csd_peaks</span><span class=\"o\">.</span><span class=\"n\">peak_values</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">fodf_peaks</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as csd_peaks.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;csd_peaks.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_csd_004.png\" srcset=\"../../_images/sphx_glr_reconst_csd_004.png\" alt=\"reconst csd\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as csd_peaks.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id6\">\n<img alt=\"examples_built/07_reconstruction/csd_peaks.png\" src=\"examples_built/07_reconstruction/csd_peaks.png\" />\n<figcaption>\n<p><span class=\"caption-text\">CSD Peaks.</span><a class=\"headerlink\" href=\"#id6\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<p>We can finally visualize both the ODFs and peaks in the same space.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">fodf_spheres</span><span class=\"o\">.</span><span class=\"n\">GetProperty</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">SetOpacity</span><span class=\"p\">(</span><span class=\"mf\">0.4</span><span class=\"p\">)</span>\n\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">fodf_spheres</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Saving illustration as csd_both.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;csd_both.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_reconst_csd_005.png\" srcset=\"../../_images/sphx_glr_reconst_csd_005.png\" alt=\"reconst csd\" class = \"sphx-glr-single-img\"/><div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Saving illustration as csd_both.png\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id7\">\n<img alt=\"examples_built/07_reconstruction/csd_both.png\" src=\"examples_built/07_reconstruction/csd_both.png\" />\n<figcaption>\n<p><span class=\"caption-text\">CSD Peaks and ODFs.</span><a class=\"headerlink\" href=\"#id7\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<section id=\"references\">\n<h3>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<div role=\"list\" class=\"citation-list\">\n<div class=\"citation\" id=\"tournier2007\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id1\">Tournier2007</a><span class=\"fn-bracket\">]</span></span>\n<p>J-D. Tournier, F. Calamante and A. Connelly, \u201cRobust\ndetermination of the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution\u201d,\nNeuroimage, vol. 35, no. 4, pp. 1459-1472, 2007.</p>\n</div>\n<div class=\"citation\" id=\"tax2014\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id2\">Tax2014</a><span class=\"fn-bracket\">]</span></span>\n<p>C.M.W. Tax, B. Jeurissen, S.B. Vos, M.A. Viergever, A. Leemans,\n\u201cRecursive calibration of the fiber response function for spherical\ndeconvolution of diffusion MRI data\u201d, Neuroimage, vol. 86, pp. 67-80, 2014.</p>\n</div>\n</div>\n<p class=\"sphx-glr-timing\"><strong>Total running time of the script:</strong> ( 1 minutes  42.700 seconds)</p>\n<div class=\"sphx-glr-footer sphx-glr-footer-example docutils container\" id=\"sphx-glr-download-examples-built-07-reconstruction-reconst-csd-py\">\n<div class=\"sphx-glr-download sphx-glr-download-python docutils container\">\n<p><a class=\"reference download internal\" download=\"\" href=\"../../../_downloads/595986d31818ecb0bb3820fb2789cec8/reconst_csd.py\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">Download</span> <span class=\"pre\">Python</span> <span class=\"pre\">source</span> <span class=\"pre\">code:</span> <span class=\"pre\">reconst_csd.py</span></code></a></p>\n</div>\n<div class=\"sphx-glr-download sphx-glr-download-jupyter docutils container\">\n<p><a class=\"reference download internal\" download=\"\" href=\"../../../_downloads/dc2c3f9569bd42eabdc28f440056d67a/reconst_csd.ipynb\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">Download</span> <span class=\"pre\">Jupyter</span> <span class=\"pre\">notebook:</span> <span class=\"pre\">reconst_csd.ipynb</span></code></a></p>\n</div>\n</div>\n<p class=\"sphx-glr-signature\"><a class=\"reference external\" href=\"https://sphinx-gallery.github.io\">Gallery generated by Sphinx-Gallery</a></p>\n</section>\n</section>\n</section>\n", "metatags": "<meta name=\"generator\" content=\"Docutils 0.19: https://docutils.sourceforge.io/\" />\n", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["examples_built/07_reconstruction/reconst_mcsd", "Reconstruction with Multi-Shell Multi-Tissue CSD", "N", "next"], ["examples_built/07_reconstruction/reconst_ivim", "Intravoxel incoherent motion", "P", "previous"]], "sourcename": "examples_built/07_reconstruction/reconst_csd.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Reconstruction with Constrained Spherical Deconvolution</a><ul>\n<li><a class=\"reference internal\" href=\"#step-1-estimation-of-the-fiber-response-function\">Step 1. Estimation of the fiber response function</a></li>\n<li><a class=\"reference internal\" href=\"#step-2-fodf-reconstruction\">Step 2. fODF reconstruction</a><ul>\n<li><a class=\"reference internal\" href=\"#references\">References</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "examples_built/07_reconstruction/reconst_csd", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}
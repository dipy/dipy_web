{"parents": [{"link": "../../../documentation/", "title": "Documentation"}, {"link": "../../", "title": "Examples"}, {"link": "../", "title": "Segmentation"}], "prev": {"link": "../fast_streamline_search/", "title": "Fast Streamline Search"}, "next": {"link": "../segment_clustering_features/", "title": "Tractography Clustering - Available Features"}, "title": "Enhancing QuickBundles with different metrics and features", "meta": null, "body": "<div class=\"sphx-glr-download-link-note admonition note\">\n<p class=\"admonition-title\">Note</p>\n<p>Click <a class=\"reference internal\" href=\"#sphx-glr-download-examples-built-23-segmentation-segment-extending-clustering-framework-py\"><span class=\"std std-ref\">here</span></a>\nto download the full example code</p>\n</div>\n<section class=\"sphx-glr-example-title\" id=\"enhancing-quickbundles-with-different-metrics-and-features\">\n<span id=\"sphx-glr-examples-built-23-segmentation-segment-extending-clustering-framework-py\"></span><h1>Enhancing QuickBundles with different metrics and features<a class=\"headerlink\" href=\"#enhancing-quickbundles-with-different-metrics-and-features\" title=\"Permalink to this heading\">\u00b6</a></h1>\n<p>QuickBundles <a class=\"reference internal\" href=\"../segment_quickbundles/#garyfallidis12\" id=\"id1\"><span>[Garyfallidis12]</span></a> is a flexible algorithm that requires only a\ndistance metric and an adjacency threshold to perform clustering. There is a\nwide variety of metrics that could be used to cluster streamlines.</p>\n<p>The purpose of this tutorial is to show how to easily create new <code class=\"docutils literal notranslate\"><span class=\"pre\">Feature</span></code>\nand new <code class=\"docutils literal notranslate\"><span class=\"pre\">Metric</span></code> classes that can be used by QuickBundles.</p>\n<section id=\"clustering-framework\">\n<span id=\"id2\"></span><h2>Clustering framework<a class=\"headerlink\" href=\"#clustering-framework\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p><a href=\"#id5\"><span class=\"problematic\" id=\"id6\">DIPY_</span></a> provides a simple, flexible and fast framework to do clustering of\nsequential data (e.g. streamlines).</p>\n<p>A <em>sequential datum</em> in DIPY is represented as a numpy array of size\n<span class=\"math notranslate nohighlight\">\\((N       imes D)\\)</span>, where each row of the array represents a <span class=\"math notranslate nohighlight\">\\(D\\)</span> dimensional\npoint of the sequence. A set of these sequences is represented as a list of\nnumpy arrays of size <span class=\"math notranslate nohighlight\">\\((N_i        imes D)\\)</span> for <span class=\"math notranslate nohighlight\">\\(i=1:M\\)</span> where <span class=\"math notranslate nohighlight\">\\(M\\)</span> is the\nnumber of sequences in the set.</p>\n<p>This clustering framework is modular and divided in three parts:</p>\n<ol class=\"arabic simple\">\n<li><p>Feature extraction</p></li>\n<li><p>Distance computation</p></li>\n<li><p>Clustering algorithm</p></li>\n</ol>\n<p>The <strong>feature extraction</strong> part includes any preprocessing needed to be done on\nthe data before computing distances between them (e.g. resampling the number of\npoints of a streamline). To define a new way of extracting features, one has to\nsubclass <code class=\"docutils literal notranslate\"><span class=\"pre\">Feature</span></code> (see below).</p>\n<p>The <strong>distance computation</strong> part includes any metric capable of evaluating a\ndistance between two sets of features previously extracted from the data. To\ndefine a new way of extracting features, one has to subclass <code class=\"docutils literal notranslate\"><span class=\"pre\">Metric</span></code> (see\nbelow).</p>\n<p>The <strong>clustering algorithm</strong> part represents the clustering algorithm itself\n(e.g. QuickBundles, K-means, Hierarchical Clustering). More precisely, it\nincludes any algorithms taking as input a list of sequential data and\noutputting a <code class=\"docutils literal notranslate\"><span class=\"pre\">ClusterMap</span></code> object.</p>\n</section>\n<section id=\"extending-feature\">\n<h2>Extending <cite>Feature</cite><a class=\"headerlink\" href=\"#extending-feature\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p>This section will guide you through the creation of a new feature extraction\nmethod that can be used in the context of this clustering framework. For a\nlist of available features in DIPY see <span class=\"xref std std-ref\">example_segment_clustering_features</span>.</p>\n<p>Assuming a set of streamlines, the type of features we want to extract is the\narc length (i.e. the sum of the length of each segment for a given streamline).</p>\n<p>Let\u2019s start by importing the necessary modules.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"kn\">import</span> <span class=\"n\">get_fnames</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.io.streamline</span> <span class=\"kn\">import</span> <span class=\"n\">load_tractogram</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"kn\">import</span> <span class=\"n\">Streamlines</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"kn\">import</span> <span class=\"n\">window</span><span class=\"p\">,</span> <span class=\"n\">actor</span><span class=\"p\">,</span> <span class=\"n\">colormap</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"kn\">import</span> <span class=\"n\">QuickBundles</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.featurespeed</span> <span class=\"kn\">import</span> <span class=\"n\">Feature</span><span class=\"p\">,</span> <span class=\"n\">VectorOfEndpointsFeature</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"kn\">import</span> <span class=\"n\">Metric</span><span class=\"p\">,</span> <span class=\"n\">SumPointwiseEuclideanMetric</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"kn\">import</span> <span class=\"n\">length</span>\n</pre></div>\n</div>\n<p>We now define the class <code class=\"docutils literal notranslate\"><span class=\"pre\">ArcLengthFeature</span></code> that will perform the desired\nfeature extraction. When subclassing <code class=\"docutils literal notranslate\"><span class=\"pre\">Feature</span></code>, two methods have to be\nredefined: <code class=\"docutils literal notranslate\"><span class=\"pre\">infer_shape</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">extract</span></code>.</p>\n<p>Also, an important property about feature extraction is whether or not\nits process is invariant to the order of the points within a streamline.\nThis is needed as there is no way one can tell which extremity of a\nstreamline is the beginning and which one is the end.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">ArcLengthFeature</span><span class=\"p\">(</span><span class=\"n\">Feature</span><span class=\"p\">):</span>\n<span class=\"w\">    </span><span class=\"sd\">&quot;&quot;&quot; Computes the arc length of a streamline. &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># The arc length stays the same even if the streamline is reversed.</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">ArcLengthFeature</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">is_order_invariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">infer_shape</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">streamline</span><span class=\"p\">):</span>\n<span class=\"w\">        </span><span class=\"sd\">&quot;&quot;&quot; Infers the shape of features extracted from `streamline`. &quot;&quot;&quot;</span>\n        <span class=\"c1\"># Arc length is a scalar</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">extract</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">streamline</span><span class=\"p\">):</span>\n<span class=\"w\">        </span><span class=\"sd\">&quot;&quot;&quot; Extracts features from `streamline`. &quot;&quot;&quot;</span>\n        <span class=\"c1\"># return np.sum(np.sqrt(np.sum((streamline[1:] - streamline[:-1]) ** 2)))</span>\n        <span class=\"c1\"># or use a DIPY&#39;s function that computes the arc length of a streamline.</span>\n        <span class=\"k\">return</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">streamline</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>The new feature extraction <code class=\"docutils literal notranslate\"><span class=\"pre\">ArcLengthFeature</span></code> is ready to be used. Let\u2019s use\nit to cluster a set of streamlines by their arc length. For educational\npurposes we will try to cluster a small streamline bundle known from\nneuroanatomy as the fornix.</p>\n<p>We start by loading the fornix streamlines.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;fornix&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">fornix</span> <span class=\"o\">=</span> <span class=\"n\">load_tractogram</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;same&#39;</span><span class=\"p\">,</span>\n                         <span class=\"n\">bbox_valid_check</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">streamlines</span>\n\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">Streamlines</span><span class=\"p\">(</span><span class=\"n\">fornix</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Perform QuickBundles clustering using the metric\n<code class=\"docutils literal notranslate\"><span class=\"pre\">SumPointwiseEuclideanMetric</span></code> and our <code class=\"docutils literal notranslate\"><span class=\"pre\">ArcLengthFeature</span></code>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">SumPointwiseEuclideanMetric</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"o\">=</span><span class=\"n\">ArcLengthFeature</span><span class=\"p\">())</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">2.</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We will now visualize the clustering result.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"c1\"># Color each streamline according to the cluster they belong to.</span>\n<span class=\"n\">cmap</span> <span class=\"o\">=</span> <span class=\"n\">colormap</span><span class=\"o\">.</span><span class=\"n\">create_colormap</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"o\">.</span><span class=\"n\">centroids</span><span class=\"p\">))</span>\n<span class=\"n\">colormap_full</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">),</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">cluster</span><span class=\"p\">,</span> <span class=\"n\">color</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"p\">):</span>\n    <span class=\"n\">colormap_full</span><span class=\"p\">[</span><span class=\"n\">cluster</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">color</span>\n\n<span class=\"n\">scene</span> <span class=\"o\">=</span> <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">Scene</span><span class=\"p\">()</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">SetBackground</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">streamtube</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">colormap_full</span><span class=\"p\">))</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;fornix_clusters_arclength.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Enables/disables interactive visualization</span>\n<span class=\"n\">interactive</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_segment_extending_clustering_framework_001.png\" srcset=\"../../_images/sphx_glr_segment_extending_clustering_framework_001.png\" alt=\"segment extending clustering framework\" class = \"sphx-glr-single-img\"/><figure class=\"align-center\" id=\"id3\">\n<img alt=\"examples_built/23_segmentation/fornix_clusters_arclength.png\" src=\"examples_built/23_segmentation/fornix_clusters_arclength.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Showing the different clusters obtained by using the arc length.</span><a class=\"headerlink\" href=\"#id3\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n</section>\n<section id=\"extending-metric\">\n<h2>Extending <cite>Metric</cite><a class=\"headerlink\" href=\"#extending-metric\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<p>This section will guide you through the creation of a new metric that can be\nused in the context of this clustering framework. For a list of available\nmetrics in DIPY see <span class=\"xref std std-ref\">example_segment_clustering_metrics</span>.</p>\n<p>Assuming a set of streamlines, we want a metric that computes the cosine\ndistance giving the vector between endpoints of each streamline (i.e. one\nminus the cosine of the angle between two vectors). For more information\nabout this distance check <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/Cosine_similarity\">http://en.wikipedia.org/wiki/Cosine_similarity</a>.</p>\n<p>Let\u2019s start by importing the necessary modules.</p>\n<p>We now define the class <code class=\"docutils literal notranslate\"><span class=\"pre\">CosineMetric</span></code> that will perform the desired\ndistance computation. When subclassing <code class=\"docutils literal notranslate\"><span class=\"pre\">Metric</span></code>, two methods have to be\nredefined: <code class=\"docutils literal notranslate\"><span class=\"pre\">are_compatible</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">dist</span></code>. Moreover, when implementing the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">dist</span></code> method, one needs to make sure the distance returned is symmetric\n(i.e. <cite>dist(A, B) == dist(B, A)</cite>).</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">CosineMetric</span><span class=\"p\">(</span><span class=\"n\">Metric</span><span class=\"p\">):</span>\n<span class=\"w\">    </span><span class=\"sd\">&quot;&quot;&quot; Computes the cosine distance between two streamlines. &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># For simplicity, features will be the vector between endpoints of a streamline.</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">CosineMetric</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"o\">=</span><span class=\"n\">VectorOfEndpointsFeature</span><span class=\"p\">())</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">are_compatible</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">shape1</span><span class=\"p\">,</span> <span class=\"n\">shape2</span><span class=\"p\">):</span>\n<span class=\"w\">        </span><span class=\"sd\">&quot;&quot;&quot; Checks if two features are vectors of same dimension.</span>\n\n<span class=\"sd\">        Basically this method exists so that we don&#39;t have to check</span>\n<span class=\"sd\">        inside the `dist` method (speedup).</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"k\">return</span> <span class=\"n\">shape1</span> <span class=\"o\">==</span> <span class=\"n\">shape2</span> <span class=\"ow\">and</span> <span class=\"n\">shape1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">dist</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">v1</span><span class=\"p\">,</span> <span class=\"n\">v2</span><span class=\"p\">):</span>\n<span class=\"w\">        </span><span class=\"sd\">&quot;&quot;&quot; Computes a the cosine distance between two vectors. &quot;&quot;&quot;</span>\n        <span class=\"n\">norm</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n        <span class=\"n\">cos_theta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">,</span> <span class=\"n\">v2</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">v2</span><span class=\"p\">))</span>\n\n        <span class=\"c1\"># Make sure it&#39;s in [-1, 1], i.e. within domain of arccosine</span>\n        <span class=\"n\">cos_theta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">minimum</span><span class=\"p\">(</span><span class=\"n\">cos_theta</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">)</span>\n        <span class=\"n\">cos_theta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">maximum</span><span class=\"p\">(</span><span class=\"n\">cos_theta</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arccos</span><span class=\"p\">(</span><span class=\"n\">cos_theta</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span>  <span class=\"c1\"># Normalized cosine distance</span>\n</pre></div>\n</div>\n<p>The new distance <code class=\"docutils literal notranslate\"><span class=\"pre\">CosineMetric</span></code> is ready to be used. Let\u2019s use\nit to cluster a set of streamlines according to the cosine distance of the\nvector between their endpoints. For educational purposes we will try to\ncluster a small streamline bundle known from neuroanatomy as the fornix.</p>\n<p>We start by loading the fornix streamlines.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;fornix&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">fornix</span> <span class=\"o\">=</span> <span class=\"n\">load_tractogram</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;same&#39;</span><span class=\"p\">,</span> <span class=\"n\">bbox_valid_check</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">fornix</span><span class=\"o\">.</span><span class=\"n\">streamlines</span>\n</pre></div>\n</div>\n<p>Perform QuickBundles clustering using our metric <code class=\"docutils literal notranslate\"><span class=\"pre\">CosineMetric</span></code>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">CosineMetric</span><span class=\"p\">()</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We will now visualize the clustering result.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"c1\"># Color each streamline according to the cluster they belong to.</span>\n<span class=\"n\">cmap</span> <span class=\"o\">=</span> <span class=\"n\">colormap</span><span class=\"o\">.</span><span class=\"n\">create_colormap</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">)))</span>\n<span class=\"n\">colormap_full</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">),</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">cluster</span><span class=\"p\">,</span> <span class=\"n\">color</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"p\">):</span>\n    <span class=\"n\">colormap_full</span><span class=\"p\">[</span><span class=\"n\">cluster</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">color</span>\n\n<span class=\"n\">scene</span> <span class=\"o\">=</span> <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">Scene</span><span class=\"p\">()</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">SetBackground</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">streamtube</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">colormap_full</span><span class=\"p\">))</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;fornix_clusters_cosine.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img src=\"../../_images/sphx_glr_segment_extending_clustering_framework_002.png\" srcset=\"../../_images/sphx_glr_segment_extending_clustering_framework_002.png\" alt=\"segment extending clustering framework\" class = \"sphx-glr-single-img\"/><figure class=\"align-center\" id=\"id4\">\n<img alt=\"examples_built/23_segmentation/fornix_clusters_cosine.png\" src=\"examples_built/23_segmentation/fornix_clusters_cosine.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Showing the different clusters obtained by using the cosine metric.</span><a class=\"headerlink\" href=\"#id4\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<section id=\"references\">\n<h3>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this heading\">\u00b6</a></h3>\n<div role=\"list\" class=\"citation-list\">\n<div class=\"citation\" id=\"garyfallidis12\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id1\">Garyfallidis12</a><span class=\"fn-bracket\">]</span></span>\n<p>Garyfallidis E. et al., QuickBundles a method for\ntractography simplification, Frontiers in Neuroscience, vol 6, no 175,\n2012.</p>\n</div>\n</div>\n<p class=\"sphx-glr-timing\"><strong>Total running time of the script:</strong> ( 0 minutes  0.268 seconds)</p>\n<div class=\"sphx-glr-footer sphx-glr-footer-example docutils container\" id=\"sphx-glr-download-examples-built-23-segmentation-segment-extending-clustering-framework-py\">\n<div class=\"sphx-glr-download sphx-glr-download-python docutils container\">\n<p><a class=\"reference download internal\" download=\"\" href=\"../../../_downloads/54b4a289ee9df94257eee86b1f686b59/segment_extending_clustering_framework.py\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">Download</span> <span class=\"pre\">Python</span> <span class=\"pre\">source</span> <span class=\"pre\">code:</span> <span class=\"pre\">segment_extending_clustering_framework.py</span></code></a></p>\n</div>\n<div class=\"sphx-glr-download sphx-glr-download-jupyter docutils container\">\n<p><a class=\"reference download internal\" download=\"\" href=\"../../../_downloads/e76ba80e5550efbd0657a1fd008bc4e3/segment_extending_clustering_framework.ipynb\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">Download</span> <span class=\"pre\">Jupyter</span> <span class=\"pre\">notebook:</span> <span class=\"pre\">segment_extending_clustering_framework.ipynb</span></code></a></p>\n</div>\n</div>\n<p class=\"sphx-glr-signature\"><a class=\"reference external\" href=\"https://sphinx-gallery.github.io\">Gallery generated by Sphinx-Gallery</a></p>\n</section>\n</section>\n</section>\n", "metatags": "<meta name=\"generator\" content=\"Docutils 0.19: https://docutils.sourceforge.io/\" />\n", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["examples_built/23_segmentation/segment_clustering_features", "Tractography Clustering - Available Features", "N", "next"], ["examples_built/23_segmentation/fast_streamline_search", "Fast Streamline Search", "P", "previous"]], "sourcename": "examples_built/23_segmentation/segment_extending_clustering_framework.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Enhancing QuickBundles with different metrics and features</a><ul>\n<li><a class=\"reference internal\" href=\"#clustering-framework\">Clustering framework</a></li>\n<li><a class=\"reference internal\" href=\"#extending-feature\">Extending <cite>Feature</cite></a></li>\n<li><a class=\"reference internal\" href=\"#extending-metric\">Extending <cite>Metric</cite></a><ul>\n<li><a class=\"reference internal\" href=\"#references\">References</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "examples_built/23_segmentation/segment_extending_clustering_framework", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}
{"parents": [], "prev": null, "next": null, "title": "Denoise images using Local PCA via empirical thresholds", "meta": {}, "body": "<div class=\"section\" id=\"denoise-images-using-local-pca-via-empirical-thresholds\">\n<span id=\"example-denoise-localpca\"></span><h1>Denoise images using Local PCA via empirical thresholds<a class=\"headerlink\" href=\"#denoise-images-using-local-pca-via-empirical-thresholds\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>PCA-based denoising algorithms are effective denoising methods because they\nexplore the redundancy of the multi-dimensional information of\ndiffusion-weighted datasets. In this example, we will show how to\nperform the PCA-based denoising using the algorithm proposed by Manjon et al.\n<a class=\"reference internal\" href=\"../denoising/denoise_mppca/#manjon2013\" id=\"id1\"><span>[Manjon2013]</span></a>.</p>\n<p>This algorithm involves the following steps:</p>\n<ul class=\"simple\">\n<li><p>First, we estimate the local noise variance at each voxel.</p></li>\n<li><p>Then, we apply PCA in local patches around each voxel over the gradient\ndirections.</p></li>\n<li><p>Finally, we threshold the eigenvalues based on the local estimate of sigma\nand then do a PCA reconstruction</p></li>\n</ul>\n<p>To perform PCA denoising without a prior noise standard deviation estimate\nplease see the following example instead: <span class=\"xref std std-ref\">denoise_mppca</span></p>\n<p>Let\u2019s load the necessary modules</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">nibabel</span> <span class=\"k\">as</span> <span class=\"nn\">nib</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"kn\">from</span> <span class=\"nn\">time</span> <span class=\"k\">import</span> <span class=\"n\">time</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.core.gradients</span> <span class=\"k\">import</span> <span class=\"n\">gradient_table</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.denoise.localpca</span> <span class=\"k\">import</span> <span class=\"n\">localpca</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.denoise.pca_noise_estimate</span> <span class=\"k\">import</span> <span class=\"n\">pca_noise_estimate</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_fnames</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.io.image</span> <span class=\"k\">import</span> <span class=\"n\">load_nifti</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.io.gradients</span> <span class=\"k\">import</span> <span class=\"n\">read_bvals_bvecs</span>\n</pre></div>\n</div>\n<p>Load one of the datasets. These data were acquired with 63 gradients and 1\nnon-diffusion (b=0) image.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">dwi_fname</span><span class=\"p\">,</span> <span class=\"n\">dwi_bval_fname</span><span class=\"p\">,</span> <span class=\"n\">dwi_bvec_fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;isbi2013_2shell&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">affine</span> <span class=\"o\">=</span> <span class=\"n\">load_nifti</span><span class=\"p\">(</span><span class=\"n\">dwi_fname</span><span class=\"p\">)</span>\n<span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span> <span class=\"o\">=</span> <span class=\"n\">read_bvals_bvecs</span><span class=\"p\">(</span><span class=\"n\">dwi_bval_fname</span><span class=\"p\">,</span> <span class=\"n\">dwi_bvec_fname</span><span class=\"p\">)</span>\n<span class=\"n\">gtab</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table</span><span class=\"p\">(</span><span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Input Volume&quot;</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"estimate-the-noise-standard-deviation\">\n<h2>Estimate the noise standard deviation<a class=\"headerlink\" href=\"#estimate-the-noise-standard-deviation\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>We use the <code class=\"docutils literal notranslate\"><span class=\"pre\">pca_noise_estimate</span></code> method to estimate the value of sigma to be\nused in local PCA algorithm proposed by Manjon et al. <a class=\"reference internal\" href=\"../denoising/denoise_mppca/#manjon2013\" id=\"id2\"><span>[Manjon2013]</span></a>.\nIt takes both data and the gradient table object as input and returns an\nestimate of local noise standard deviation as a 3D array. We return a smoothed\nversion, where a Gaussian filter with radius 3 voxels has been applied to the\nestimate of the noise before returning it.</p>\n<p>We correct for the bias due to Rician noise, based on an equation developed by\nKoay and Basser <a class=\"reference internal\" href=\"../denoising/denoise_localpca/#koay2006\" id=\"id3\"><span>[Koay2006]</span></a>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"p\">()</span>\n<span class=\"n\">sigma</span> <span class=\"o\">=</span> <span class=\"n\">pca_noise_estimate</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">correct_bias</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">smooth</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Sigma estimation time&quot;</span><span class=\"p\">,</span> <span class=\"n\">time</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"perform-the-localpca-using-the-function-localpca\">\n<h2>Perform the localPCA using the function <cite>localpca</cite><a class=\"headerlink\" href=\"#perform-the-localpca-using-the-function-localpca\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The localpca algorithm takes into account the multi-dimensional information of\nthe diffusion MR data. It performs PCA on local 4D patch and\nthen removes the noise components by thresholding the lowest eigenvalues.\nThe eigenvalue threshold will be computed from the local variance estimate\nperformed by the <code class=\"docutils literal notranslate\"><span class=\"pre\">pca_noise_estimate</span></code> function, if this is inputted in the\nmain <code class=\"docutils literal notranslate\"><span class=\"pre\">localpca</span></code> function. The relationship between the noise variance\nestimate and the eigenvalue threshold can be adjusted using the input parameter\n<code class=\"docutils literal notranslate\"><span class=\"pre\">tau_factor</span></code>. According to Manjon et al. <a class=\"reference internal\" href=\"../denoising/denoise_mppca/#manjon2013\" id=\"id4\"><span>[Manjon2013]</span></a>, this parameter is set\nto 2.3.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"p\">()</span>\n\n<span class=\"n\">denoised_arr</span> <span class=\"o\">=</span> <span class=\"n\">localpca</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">,</span> <span class=\"n\">tau_factor</span><span class=\"o\">=</span><span class=\"mf\">2.3</span><span class=\"p\">,</span> <span class=\"n\">patch_radius</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Time taken for local PCA (slow)&quot;</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"n\">t</span> <span class=\"o\">+</span> <span class=\"n\">time</span><span class=\"p\">())</span>\n</pre></div>\n</div>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">localpca</span></code> function returns the denoised data which is plotted below\n(middle panel) together with the original version of the data (left panel) and\nthe algorithm residual (right panel) .</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">sli</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">//</span> <span class=\"mi\">2</span>\n<span class=\"n\">gra</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"o\">//</span> <span class=\"mi\">2</span>\n<span class=\"n\">orig</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"n\">sli</span><span class=\"p\">,</span> <span class=\"n\">gra</span><span class=\"p\">]</span>\n<span class=\"n\">den</span> <span class=\"o\">=</span> <span class=\"n\">denoised_arr</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"n\">sli</span><span class=\"p\">,</span> <span class=\"n\">gra</span><span class=\"p\">]</span>\n<span class=\"n\">rms_diff</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">((</span><span class=\"n\">orig</span> <span class=\"o\">-</span> <span class=\"n\">den</span><span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">orig</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span><span class=\"p\">,</span> <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"s1\">&#39;lower&#39;</span><span class=\"p\">,</span> <span class=\"n\">interpolation</span><span class=\"o\">=</span><span class=\"s1\">&#39;none&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"s1\">&#39;Original&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_axis_off</span><span class=\"p\">()</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">den</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span><span class=\"p\">,</span> <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"s1\">&#39;lower&#39;</span><span class=\"p\">,</span> <span class=\"n\">interpolation</span><span class=\"o\">=</span><span class=\"s1\">&#39;none&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"s1\">&#39;Denoised Output&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_axis_off</span><span class=\"p\">()</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">rms_diff</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span><span class=\"p\">,</span> <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"s1\">&#39;lower&#39;</span><span class=\"p\">,</span> <span class=\"n\">interpolation</span><span class=\"o\">=</span><span class=\"s1\">&#39;none&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"s1\">&#39;Residual&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_axis_off</span><span class=\"p\">()</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">savefig</span><span class=\"p\">(</span><span class=\"s1\">&#39;denoised_localpca.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">bbox_inches</span><span class=\"o\">=</span><span class=\"s1\">&#39;tight&#39;</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;The result saved in denoised_localpca.png&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"figure align-center\">\n<img alt=\"../../_images/denoised_localpca.png\" src=\"../../_images/denoised_localpca.png\" />\n</div>\n<p>Below we show how the denoised data can be saved.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">nib</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"n\">nib</span><span class=\"o\">.</span><span class=\"n\">Nifti1Image</span><span class=\"p\">(</span><span class=\"n\">denoised_arr</span><span class=\"p\">,</span>\n                         <span class=\"n\">affine</span><span class=\"p\">),</span> <span class=\"s1\">&#39;denoised_localpca.nii.gz&#39;</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Entire denoised data saved in denoised_localpca.nii.gz&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"manjon2013\"><span class=\"brackets\">Manjon2013</span><span class=\"fn-backref\">(<a href=\"#id1\">1</a>,<a href=\"#id2\">2</a>,<a href=\"#id4\">3</a>)</span></dt>\n<dd><p>Manjon JV, Coupe P, Concha L, Buades A, Collins DL \u201cDiffusion\nWeighted Image Denoising Using Overcomplete Local PCA\u201d (2013).\nPLoS ONE 8(9): e73021. doi:10.1371/journal.pone.0073021.</p>\n</dd>\n<dt class=\"label\" id=\"koay2006\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id3\">Koay2006</a></span></dt>\n<dd><p>Koay CG, Basser PJ (2006). \u201cAnalytically exact correction scheme\nfor signal extraction from noisy magnitude MR signals\u201d. JMR 179:\n317-322.</p>\n</dd>\n</dl>\n<div class=\"admonition-example-source-code admonition\">\n<p class=\"admonition-title\">Example source code</p>\n<p>You can download <a class=\"reference download internal\" download=\"\" href=\"../../_downloads/1e56d15cb2f9f148b70ea0b79f49ea3d/denoise_localpca.py\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">the</span> <span class=\"pre\">full</span> <span class=\"pre\">source</span> <span class=\"pre\">code</span> <span class=\"pre\">of</span> <span class=\"pre\">this</span> <span class=\"pre\">example</span></code></a>. This same script is also included in the dipy source distribution under the <code class=\"file docutils literal notranslate\"><span class=\"pre\">doc/examples/</span></code> directory.</p>\n</div>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"]], "sourcename": "examples_built/denoise_localpca.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Denoise images using Local PCA via empirical thresholds</a><ul>\n<li><a class=\"reference internal\" href=\"#estimate-the-noise-standard-deviation\">Estimate the noise standard deviation</a></li>\n<li><a class=\"reference internal\" href=\"#perform-the-localpca-using-the-function-localpca\">Perform the localPCA using the function <cite>localpca</cite></a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "examples_built/denoise_localpca", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}